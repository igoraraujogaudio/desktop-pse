{
    "docs": [
        {
            "location": "/",
            "text": "Introdu\u00e7\u00e3o\n\n\nO Leitor Biom\u00e9trico iDBio, desenvolvido pela Control iD, permite capturar digitais com alta qualidade e, em sua vers\u00e3o Pro, possibilita tamb\u00e9m identifica\u00e7\u00e3o e valida\u00e7\u00e3o biom\u00e9trica de forma r\u00e1pida e segura\n\n\n\n\nEste documento serve de ref\u00eancia para o usu\u00e1rio que deseja integar o seu software ao leitor biom\u00e9trico iDBio.\n\n\nEspecifica\u00e7\u00f5es T\u00e9cnicas\n\n\n\n\n\n\n\n\nFeatures\n\n\niDBio\n\n\n\n\n\n\n\n\n\n\n\u00c1rea do scanner\n\n\n21 x 19 mm\n\n\n\n\n\n\nResolu\u00e7\u00e3o da imagem\n\n\n500 DPI\n\n\n\n\n\n\nFormato da imagem\n\n\n256 n\u00edveis de cinza\n\n\n\n\n\n\nInterface USB\n\n\nComunica\u00e7\u00e3o de alta velocidade\n\n\n\n\n\n\nSinalizador sonoro\n\n\nBuzzer para melhor usabilidade\n\n\n\n\n\n\nCabo USB integrado\n\n\nComprimento de 1,5m\n\n\n\n\n\n\nR\u00e1pida Identifi\u00e7\u00e3o*\n\n\nMais de 1000 usu\u00e1rios em menos de 1s\n\n\n\n\n\n\nConfiabilidade*\n\n\nAlgoritmo biom\u00e9trico de alto desempenho\n\n\n\n\n\n\nDimens\u00f5es\n\n\n58 x 67 x 58 mm (L x A x P)\n\n\n\n\n\n\nPeso do equipamento\n\n\n130g\n\n\n\n\n\n\nAlimenta\u00e7\u00e3o\n\n\n5V (fornecido via USB)\n\n\n\n\n\n\nConsumo Total\n\n\n2,5 W\n\n\n\n\n\n\n\n\n* Dispon\u00edvel somente na vers\u00e3o PRO\n\n\nCondi\u00e7\u00f5es de armazenamento e funcionamento\n\n\nPara garantir o bom funcionamento e a durabilidade do iDBio recomenda-se que este seja\ninstalado em ambiente protegido contra exposi\u00e7\u00e3o solar direta, chuva e outros fen\u00f4menos\nclim\u00e1ticos. Al\u00e9m disso, as condi\u00e7\u00f5es de funcionamento e armazenamento descritas abaixo\ndevem ser respeitadas.\n\n\nCondi\u00e7\u00f5es de funcionamento:\n\n\n\n\nTemperatura ambiente entre 0 \u00baC e 50 \u00baC;\n\n\nUmidade relativa do ar entre 10% e 80%;\n\n\nAltitude inferior a 3.000 m;\n\n\n\n\nCondi\u00e7\u00f5es de armazenamento:\n\n\n\n\nTemperatura entre 0 \u00baC e 50 \u00baC;\n\n\nUmidade relativa do ar entre 10% e 80%;\n\n\nAltitude inferior a 10.000 m;",
            "title": "Principal"
        },
        {
            "location": "/#introducao",
            "text": "O Leitor Biom\u00e9trico iDBio, desenvolvido pela Control iD, permite capturar digitais com alta qualidade e, em sua vers\u00e3o Pro, possibilita tamb\u00e9m identifica\u00e7\u00e3o e valida\u00e7\u00e3o biom\u00e9trica de forma r\u00e1pida e segura   Este documento serve de ref\u00eancia para o usu\u00e1rio que deseja integar o seu software ao leitor biom\u00e9trico iDBio.",
            "title": "Introdu\u00e7\u00e3o"
        },
        {
            "location": "/#especificacoes-tecnicas",
            "text": "Features  iDBio      \u00c1rea do scanner  21 x 19 mm    Resolu\u00e7\u00e3o da imagem  500 DPI    Formato da imagem  256 n\u00edveis de cinza    Interface USB  Comunica\u00e7\u00e3o de alta velocidade    Sinalizador sonoro  Buzzer para melhor usabilidade    Cabo USB integrado  Comprimento de 1,5m    R\u00e1pida Identifi\u00e7\u00e3o*  Mais de 1000 usu\u00e1rios em menos de 1s    Confiabilidade*  Algoritmo biom\u00e9trico de alto desempenho    Dimens\u00f5es  58 x 67 x 58 mm (L x A x P)    Peso do equipamento  130g    Alimenta\u00e7\u00e3o  5V (fornecido via USB)    Consumo Total  2,5 W     * Dispon\u00edvel somente na vers\u00e3o PRO",
            "title": "Especifica\u00e7\u00f5es T\u00e9cnicas"
        },
        {
            "location": "/#condicoes-de-armazenamento-e-funcionamento",
            "text": "Para garantir o bom funcionamento e a durabilidade do iDBio recomenda-se que este seja\ninstalado em ambiente protegido contra exposi\u00e7\u00e3o solar direta, chuva e outros fen\u00f4menos\nclim\u00e1ticos. Al\u00e9m disso, as condi\u00e7\u00f5es de funcionamento e armazenamento descritas abaixo\ndevem ser respeitadas.  Condi\u00e7\u00f5es de funcionamento:   Temperatura ambiente entre 0 \u00baC e 50 \u00baC;  Umidade relativa do ar entre 10% e 80%;  Altitude inferior a 3.000 m;   Condi\u00e7\u00f5es de armazenamento:   Temperatura entre 0 \u00baC e 50 \u00baC;  Umidade relativa do ar entre 10% e 80%;  Altitude inferior a 10.000 m;",
            "title": "Condi\u00e7\u00f5es de armazenamento e funcionamento"
        },
        {
            "location": "/1_sdk/",
            "text": "SDK\n\n\nA comunica\u00e7\u00e3o com o leitor biom\u00e9trico iDBio pode ser feita atrav\u00e9s de uma biblioteca em C que pode ser encontrada no \nKit de desenvolvimento do iDBIO\n. Esta biblioteca \u00e9 comp\u00e1tivel com Windows e linux (32 e 64 bits).\n\n\nO Kit de desenvolvimento tamb\u00e9m cont\u00e9m um Wrapper em C++ para facilitar o desenvolvimento caso esta seja sua linguagem de prefer\u00eancia.",
            "title": "SDK"
        },
        {
            "location": "/1_sdk/#sdk",
            "text": "A comunica\u00e7\u00e3o com o leitor biom\u00e9trico iDBio pode ser feita atrav\u00e9s de uma biblioteca em C que pode ser encontrada no  Kit de desenvolvimento do iDBIO . Esta biblioteca \u00e9 comp\u00e1tivel com Windows e linux (32 e 64 bits).  O Kit de desenvolvimento tamb\u00e9m cont\u00e9m um Wrapper em C++ para facilitar o desenvolvimento caso esta seja sua linguagem de prefer\u00eancia.",
            "title": "SDK"
        },
        {
            "location": "/2_c_reference/",
            "text": "Introdu\u00e7\u00e3o\n\n\nA biblioteca em C pode ser encontrada no \nKit de desenvolvimento do iDBIO\n. Os headers com as defini\u00e7\u00f5es das fun\u00e7\u00f5es est\u00e3o dispon\u00edveis na pasta \"include\". Esta biblioteca apresenta 3 vers\u00f5es: Linux x86, Linux x64 e Windows.\n\n\nPara utilizar a biblioteca em seu projeto basta \"linkar\" a mesma ao seu execut\u00e1vel. \n\n\nExemplo com gcc:\n\n\ngcc example.c -lcidbio -o example\n\n\n\n\nC\u00f3digos de Retorno\n\n\nint32_t \nCIDBIO_GetErrorMessage\n (int32_t error, char** msg)\n\n\nRetorna mensagem em ingl\u00eas do erro passado.\n\n\nPar\u00e2metros de entrada:* \n\n\n\n\nerror: \nint32_t\n\n    C\u00f3digo de erro\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n\n\n\n\nmsg: \nchar**\n\n    Descri\u00e7\u00e3o em ingl\u00eas do erro.\n\n    Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\n\n\nTodas as fun\u00e7\u00f5es desta biblioteca retornam um n\u00famero inteiro. Este c\u00f3digo de retorno pode indicar uma das 3 situa\u00e7\u00f5es abaixo: \n\n\n\n\nSucesso (== 0) - Opera\u00e7\u00e3o foi realizada com sucesso \n\n\nAviso (> 0) - Opera\u00e7\u00e3o foi realizada mas com alguma ressalva\n\n\nErro (< 0) - Opera\u00e7\u00e3o falhou\n\n\n\n\n\n\n\n\n\n\nValor\n\n\nDefine\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\n0\n\n\nCIDBIO_SUCCESS\n\n\nOpera\u00e7\u00e3o realizada com sucesso\n\n\n\n\n\n\n1\n\n\nCIDBIO_WARNING_ALREADY_INIT\n\n\nBiblioteca j\u00e1 inicializada\n\n\n\n\n\n\n2\n\n\nCIDBIO_WARNING_NO_IDS_ON_DEVICE\n\n\nNenhum Template cadastrado\n\n\n\n\n\n\n3\n\n\nCIDBIO_WARNING_OVERWRITING_TEMPLATE\n\n\nTemplate foi sobrescrito\n\n\n\n\n\n\n-1\n\n\nCIDBIO_ERROR_UNKNOWN\n\n\nErro desconhecido\n\n\n\n\n\n\n-2\n\n\nCIDBIO_ERROR_NO_DEVICE\n\n\nDispositivo n\u00e3o encontrado\n\n\n\n\n\n\n-3\n\n\nCIDBIO_ERROR_NULL_ARGUMENT\n\n\nArgumento nulo\n\n\n\n\n\n\n-4\n\n\nCIDBIO_ERROR_INVALID_ARGUMENT\n\n\nArgumento inv\u00e1lido\n\n\n\n\n\n\n-5\n\n\nCIDBIO_ERROR_CAPTURE\n\n\nErro durante a captura\n\n\n\n\n\n\n-6\n\n\nCIDBIO_ERROR_CAPTURE_TIMEOUT\n\n\nTempo de captura expirado\n\n\n\n\n\n\n-7\n\n\nCIDBIO_ERROR_COMM_USB\n\n\nErro de comunica\u00e7\u00e3o USB\n\n\n\n\n\n\n-8\n\n\nCIDBIO_ERROR_IO_ON_HOST\n\n\nErro de comunica\u00e7\u00e3o do Host\n\n\n\n\n\n\n-9\n\n\nCIDBIO_ERROR_TEMPLATE_ALREADY_ENROLLED\n\n\nTemplate j\u00e1 cadastrado\n\n\n\n\n\n\n-10\n\n\nCIDBIO_ERROR_MERGING\n\n\nFalha no Merge\n\n\n\n\n\n\n-11\n\n\nCIDBIO_ERROR_MATCHING\n\n\nFalha no Match\n\n\n\n\n\n\n-12\n\n\nCIDBIO_ERROR_INVALID_FW_FILE\n\n\nArquivo de Firmware inv\u00e1lido\n\n\n\n\n\n\n-13\n\n\nCIDBIO_ERROR_NO_SPACE_LEFT_ON_DEVICE\n\n\nEspa\u00e7o no dispositivo esgotado\n\n\n\n\n\n\n-14\n\n\nCIDBIO_ERROR_NO_TEMPLATE_WITH_ID\n\n\nTemplate n\u00e3o cadastrado\n\n\n\n\n\n\n-15\n\n\nCIDBIO_ERROR_INVALID_ERRNO\n\n\nC\u00f3digo de erro inv\u00e1lido\n\n\n\n\n\n\n-16\n\n\nCIDBIO_ERROR_UNAVAILABLE_FEATURE\n\n\nFuncionalidade n\u00e3o dispon\u00edvel\n\n\n\n\n\n\n-17\n\n\nCIDBIO_ERROR_PREVIOUS_FW_VERSION\n\n\nVers\u00e3o do firmware \u00e9 anterior \u00e0 atual\n\n\n\n\n\n\n-18\n\n\nCIDBIO_ERROR_NOT_IDENTIFIED\n\n\nTemplate n\u00e3o identificado\n\n\n\n\n\n\n-19\n\n\nCIDBIO_ERROR_BUSY\n\n\nDispositivo esta ocupado\n\n\n\n\n\n\n-20\n\n\nCIDBIO_ERROR_CAPTURE_CANCELED\n\n\nCaptura foi cancelada\n\n\n\n\n\n\n-21\n\n\nCIDBIO_ERROR_NO_FINGER_DETECTED\n\n\nDigital n\u00e3o foi detectada\n\n\n\n\n\n\n\n\nInicializa\u00e7\u00e3o e Finaliza\u00e7\u00e3o\n\n\nint32_t \nCIDBIO_SetSerialCommPort\n (char* comPort)\n\n\nConfigura em qual porta o dispositivo deve se conectar.\n\nDispon\u00edvel a partir da vers\u00e3o da SDK: \n1.4.0\n\n\nPar\u00e2metro de entrada:\n  \n\n\n\n\ncomPort: \nchar*\n\n   Porta serial ao qual o dispositivo deve se conectar. Deve ser \"COMx\" em Windows e \"/dev/ttyACMx\" em Linux\n\n\n\n\nint32_t \nCIDBIO_Init\n (void)\n\n\nCheca e inicializa o dispositivo.\n\n\nint32_t \nCIDBIO_Terminate\n (void)\n\n\nFinaliza o dispositivo.\n\n\nCaptura de dedo\n\n\nint32_t \nCIDBIO_CaptureImage\n (byte** imageBuf, uint32_t* width, uint32_t* height)\n\n\nCaptura uma imagem de um dedo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nimageBuf: \nbyte**\n\n   Buffer com o conte\u00fado bitmap da imagem.\n\n   Usar \nCIDBIO_FreeByteArray()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\nwidth: \nuint32_t*\n\n   Largura da imagem\n\n\nheight: \nuint32_t*\n\n   Altura da imagem\n\n\n\n\nint32_t \nCIDBIO_CheckFingerprint\n (byte** imageBuf, uint32_t* width, uint32_t* height)\n\n\nCheca se existe um dedo pressionando o leitor. Em caso positivo a imagem da digital \u00e9 retornada, em caso negativo o erro \nCIDBIO_ERROR_NO_FINGER_DETECTED\n \u00e9 retornado. Esta fun\u00e7\u00e3o sempre retorna imediatamente.\n\nDispon\u00edvel a partir da vers\u00e3o do firmware: \n1.2.0\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nimageBuf: \nbyte**\n\n   Buffer com o conte\u00fado bitmap da imagem.\n\n   Usar \nCIDBIO_FreeByteArray()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\nwidth: \nuint32_t*\n\n   Largura da imagem\n\n\nheight: \nuint32_t*\n\n   Altura da imagem\n\n\n\n\nint32_t \nCIDBIO_CaptureImageAndTemplate\n (char** temp, byte** imageBuf, uint32_t* width, uint32_t* height, int32_t* quality)\n\n\nCaptura uma imagem de um dedo e extrai o seu template. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispostivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nchar**\n\n   Base64 do template extra\u00eddo.\n\n   Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\nimageBuf: \nbyte**\n\n   Buffer com o conte\u00fado bitmap da imagem.\n\n   Usar \nCIDBIO_FreeByteArray()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\nwidth: \nuint32_t*\n\n   Largura da imagem\n\n\nheight: \nuint32_t*\n\n   Altura da imagem.\n\n\nquality: \nint32_t*\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\nint32_t \nCIDBIO_CaptureAndEnroll\n (int64_t id)\n\n\nCaptura 3 imagens de um dedo e o cadastra no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado 3 vezes, ou o tempo de captura for expirado (30 segundos por itera\u00e7\u00e3o). \n\n\nPar\u00e2metro de entrada:\n  \n\n\n\n\nid: \nint64_t\n\n   N\u00famero identificador do template\n\n\n\n\nint32_t \nCIDBIO_CaptureAndIdentify\n (int64_t* id, int32_t* score, int32_t* quality)\n\n\nCaptura uma imagem de um dedo e tenta encontrar uma biometria semelhante cadastrada no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nid: \nint64_t*\n\n   N\u00famero identificador do template encontrado.\n\n\nscore: \nint32_t*\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.\n\n\nquality: \nint32_t*\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\nint32_t \nCIDBIO_CaptureAndMatch\n (int64_t id, int32_t* score, int32_t* quality)\n\n\nCaptura uma imagem de um dedo e verifica a semelhan\u00e7a com a biometria cadastrada com identificador \nid\n. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nid: \nint64_t\n\n   N\u00famero identificador do template a ser comparado.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint32_t*\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.\n\n\nquality: \nint32_t*\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\nint32_t \nCIDBIO_CancelCapture\n ()\n\n\nCancela a opera\u00e7\u00e3o de captura atual.\n\nDispon\u00edvel a partir da vers\u00e3o do firmware: \n1.2.0\n\n\nGerenciar Templates\n\n\nint32_t \nCIDBIO_ExtractTemplateFromImage\n (uint32_t width, uint32_t height, byte* imageBuf, char** temp, int32_t* quality)\n\n\nExtrai o template de uma imagem.\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nwidth: \nuint32_t\n\n   Largura da imagem\n\n\nheight: \nuint32_t\n\n   Altura da imagem.\n\n\nimageBuf: \nbyte*\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nchar**\n\n   Base64 do template extra\u00eddo.\n\n   Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\nquality: \nint32_t*\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\nint32_t \nCIDBIO_MergeTemplates\n (char* temp1, char* temp2, char* temp3, char** tempFinal)\n\n\nMescla 3 templates em um \u00fanico template. Templates devem pertencer ao mesmo dedo. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\ntemp1: \nchar*\n\n   Base64 do primeiro template. \n\n\ntemp2: \nchar*\n\n   Base64 do segundo template.\n\n\ntemp3: \nchar*\n\n   Base64 do terceiro template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntempFinal: \nchar**\n\n   Base64 do template mesclado.\n\n   Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\n\n\nint32_t \nCIDBIO_MatchTemplates\n (char* temp1, char* temp2, int32_t* score)\n\n\nVerifica se 2 templates s\u00e3o iguais. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\ntemp1: \nchar*\n\n   Base64 do primeiro template.  \n\n\ntemp2: \nchar*\n\n   Base64 do segundo template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint32_t*\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.\n\n\n\n\nint32_t \nCIDBIO_MatchTemplateByID\n (int64_t id, char* temp, int32_t* score)\n\n\nVerifica se o template \ntemp\n \u00e9 igual ao template cadastrado com identificador \nid\n. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nid: \nint64_t\n\n   identificador do template a ser verificado.\n\n\ntemp: \nchar*\n\n   Base64 do template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint32_t*\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.\n\n\n\n\nint32_t \nCIDBIO_GetTemplateIDs\n (int64_t** ids, uint32_t* len)\n\n\nCarrega os identificadores de todos templates cadastrados.\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nids: \nint64_t**\n\n   Identificadores de todos os templates cadastros no dispositivo.\n\n   Usar \nCIDBIO_FreeIDArray()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\nlen: \nuint32_t*\n\n   N\u00famero de templates cadastros no dispositivo.\n\n\n\n\nint32_t \nCIDBIO_GetTemplate\n (int64_t id, char** temp)\n\n\nCarrega o template cadastrado com identificador \nid\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nid: \nint64_t\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nchar**\n\n   Base64 do template.\n\n   Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\n\n\nint32_t \nCIDBIO_SaveTemplate\n (int64_t id, char* temp)\n\n\nSalva o template \ntemp\n com o identificador \nid\n. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n\n\n\n\n\n\nid: \nint64_t\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\n\n\ntemp: \nchar*\n\n   Base64 do template.\n\n\n\n\n\n\nint32_t \nCIDBIO_DeleteTemplate\n (int64_t id)\n\n\nDeleta o template cadastrado com identificador \nid\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nid: \nint64_t\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\nint32_t \nCIDBIO_DeleteAllTemplates\n (void)\n\n\nDeleta todos os template cadastrados no dispositivo.\n\n\nConfigura\u00e7\u00e3o do dispositivo\n\n\n\u00c9 poss\u00edvel alterar o comportamento do dispositivo atr\u00e1ves das configura\u00e7\u00f5es abaixo:\n\n\n\n\n\n\n\n\nValor\n\n\nDefine\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\n1\n\n\nCIDBIO_PARAM_MIN_VAR\n\n\nVari\u00e2ncia m\u00ednima para captura de um dedo. (padr\u00e3o: \"1000\")\n\n\n\n\n\n\n2\n\n\nCIDBIO_PARAM_SIMILIARITY_THRESHOLD\n\n\nValor de 1 a 20000 que determina o valor m\u00ednimo para 2 templates serem considerados iguais. Valor 0 para autom\u00e1tico (padr\u00e3o)\n\n\n\n\n\n\n4\n\n\nCIDBIO_PARAM_BUZZER_ON\n\n\n\"1\" (padr\u00e3o) ou \"0\" para ligar ou desligar o buzzer\n\n\n\n\n\n\n5\n\n\nCIDBIO_PARAM_TEMPLATE_FORMAT\n\n\nConfigura o formato do template. Valores poss\u00edveis:\n\"\nICS\n\": Formato propriet\u00e1rio (padr\u00e3o) \n\"\nANSI\n\": Formato ANSI (Somente para exporta\u00e7\u00e3o de templates)\n\"\nISO\n\": Formato ISO  (Somente para exporta\u00e7\u00e3o de templates)\n\"\nANSI_PLUS\n\": Formato ANSI com informa\u00e7\u00f5es propriet\u00e1rias \n\"\nISO_PLUS\n\": Formato ISO com informa\u00e7\u00f5es propriet\u00e1rias\n\n\n\n\n\n\n6\n\n\nCIDBIO_PARAM_ROTATION\n\n\nRota\u00e7\u00e3o m\u00e1xima aceita para que dois dedos sejam aceitos como iguais. Esta rota\u00e7\u00e3o \u00e9 aplicada no sentido hor\u00e1rio e anti-hor\u00e1rio. Este par\u00e2metro impacta na velocidade de identifica\u00e7\u00e3o, quanto maior este valor, mais tempo a identifica\u00e7\u00e3o demorar\u00e1. Valor de 0 a 180 (padr\u00e3o: \"30\")\n\n\n\n\n\n\n7\n\n\nCIDBIO_PARAM_DETECT_TIMEOUT\n\n\nTempo, em milissegundos, de espera para detec\u00e7\u00e3o de um dedo. (padr\u00e3o: \"30000\")\n\n\n\n\n\n\n\n\nint32_t \nCIDBIO_SetParameter\n (int32_t config, char* value)\n\n\nConfigura o par\u00e2metro \nconfig\n com o valor \nvalue\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nconfig: \nint32_t\n\n   Par\u00e2metro a ser configurado\n\n\nvalue: \nchar*\n\n   Valor a ser configurado.\n\n\n\n\nint32_t \nCIDBIO_GetParameter\n (int32_t config, char** value)\n\n\nL\u00ea o valor do par\u00e2metro \nconfig\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nconfig: \nint32_t\n\n   Par\u00e2metro a ser configurado\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n\n\n\n\nvalue: \nchar**\n\n   Valor atual do par\u00e2metro.\n\n   Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\n\n\nint32_t \nCIDBIO_GetDeviceInfo\n (char** version, char** serialNumber, char** model)\n\n\nL\u00ea as informa\u00e7\u00f5es do dispositivo.\n\n\nPar\u00e2metros de sa\u00edda:\n\n\n\n\nversion: _char**\n\n   Vers\u00e3o do firmware do dispositivo.\n\n   Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\nserialNumber: \nchar**\n\n   N\u00famero de s\u00e9rie do dispositivo.\n\n   Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\nmodel: \nchar**\n\n   Modelo do dispositivo.\n\n   Usar \nCIDBIO_FreeString()\n para liberar mem\u00f3ria deste par\u00e2metro.\n\n\n\n\nint32_t \nCIDBIO_UpdateFirmware\n (char* filePath)\n\n\nAtualiza o firmware do dispositivo com o arquivo em \nfilePath\n. Este procedimento pode demorar alguns minutos. Por favor, n\u00e3o desconecte o dispositivo durante este per\u00edodo, pois isto pode danificar o dispositivo de forma permanente.\n\nA \u00faltima vers\u00e3o do fimware pode ser encontrada \naqui\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nfilePath: \nchar*\n \n\n   Caminho completo para o arquivo contendo a atualiza\u00e7\u00e3o de firmware.\n\n\n\n\nDesaloca\u00e7\u00e3o de mem\u00f3ria\n\n\nint32_t \nCIDBIO_FreeByteArray\n (byte* array)\n\n\nDesaloca mem\u00f3ria de um array de bytes.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\narray: \nbyte*\n \n\n   Array de bytes a ser desalocado da mem\u00f3ria.\n\n\n\n\nint32_t \nCIDBIO_FreeString\n (char* str)\n\n\nDesaloca mem\u00f3ria de uma string de c.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nstr: \nchar*\n \n\n   String a ser desalocado da mem\u00f3ria.\n\n\n\n\nint32_t \nCIDBIO_FreeIDArray\n (int64_t* ids)\n\n\nDesaloca mem\u00f3ria de um array de inteiros de 64 bits.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nids: \nint64_t*\n \n\n   Array de inteiros de 64 bits a ser desalocado da mem\u00f3ria.",
            "title": "Refer\u00eancia C"
        },
        {
            "location": "/2_c_reference/#introducao",
            "text": "A biblioteca em C pode ser encontrada no  Kit de desenvolvimento do iDBIO . Os headers com as defini\u00e7\u00f5es das fun\u00e7\u00f5es est\u00e3o dispon\u00edveis na pasta \"include\". Esta biblioteca apresenta 3 vers\u00f5es: Linux x86, Linux x64 e Windows.  Para utilizar a biblioteca em seu projeto basta \"linkar\" a mesma ao seu execut\u00e1vel.   Exemplo com gcc:  gcc example.c -lcidbio -o example",
            "title": "Introdu\u00e7\u00e3o"
        },
        {
            "location": "/2_c_reference/#codigos-de-retorno",
            "text": "int32_t  CIDBIO_GetErrorMessage  (int32_t error, char** msg)  Retorna mensagem em ingl\u00eas do erro passado.  Par\u00e2metros de entrada:*    error:  int32_t \n    C\u00f3digo de erro   Par\u00e2metros de sa\u00edda:   msg:  char** \n    Descri\u00e7\u00e3o em ingl\u00eas do erro. \n    Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.   Todas as fun\u00e7\u00f5es desta biblioteca retornam um n\u00famero inteiro. Este c\u00f3digo de retorno pode indicar uma das 3 situa\u00e7\u00f5es abaixo:    Sucesso (== 0) - Opera\u00e7\u00e3o foi realizada com sucesso   Aviso (> 0) - Opera\u00e7\u00e3o foi realizada mas com alguma ressalva  Erro (< 0) - Opera\u00e7\u00e3o falhou      Valor  Define  Descri\u00e7\u00e3o      0  CIDBIO_SUCCESS  Opera\u00e7\u00e3o realizada com sucesso    1  CIDBIO_WARNING_ALREADY_INIT  Biblioteca j\u00e1 inicializada    2  CIDBIO_WARNING_NO_IDS_ON_DEVICE  Nenhum Template cadastrado    3  CIDBIO_WARNING_OVERWRITING_TEMPLATE  Template foi sobrescrito    -1  CIDBIO_ERROR_UNKNOWN  Erro desconhecido    -2  CIDBIO_ERROR_NO_DEVICE  Dispositivo n\u00e3o encontrado    -3  CIDBIO_ERROR_NULL_ARGUMENT  Argumento nulo    -4  CIDBIO_ERROR_INVALID_ARGUMENT  Argumento inv\u00e1lido    -5  CIDBIO_ERROR_CAPTURE  Erro durante a captura    -6  CIDBIO_ERROR_CAPTURE_TIMEOUT  Tempo de captura expirado    -7  CIDBIO_ERROR_COMM_USB  Erro de comunica\u00e7\u00e3o USB    -8  CIDBIO_ERROR_IO_ON_HOST  Erro de comunica\u00e7\u00e3o do Host    -9  CIDBIO_ERROR_TEMPLATE_ALREADY_ENROLLED  Template j\u00e1 cadastrado    -10  CIDBIO_ERROR_MERGING  Falha no Merge    -11  CIDBIO_ERROR_MATCHING  Falha no Match    -12  CIDBIO_ERROR_INVALID_FW_FILE  Arquivo de Firmware inv\u00e1lido    -13  CIDBIO_ERROR_NO_SPACE_LEFT_ON_DEVICE  Espa\u00e7o no dispositivo esgotado    -14  CIDBIO_ERROR_NO_TEMPLATE_WITH_ID  Template n\u00e3o cadastrado    -15  CIDBIO_ERROR_INVALID_ERRNO  C\u00f3digo de erro inv\u00e1lido    -16  CIDBIO_ERROR_UNAVAILABLE_FEATURE  Funcionalidade n\u00e3o dispon\u00edvel    -17  CIDBIO_ERROR_PREVIOUS_FW_VERSION  Vers\u00e3o do firmware \u00e9 anterior \u00e0 atual    -18  CIDBIO_ERROR_NOT_IDENTIFIED  Template n\u00e3o identificado    -19  CIDBIO_ERROR_BUSY  Dispositivo esta ocupado    -20  CIDBIO_ERROR_CAPTURE_CANCELED  Captura foi cancelada    -21  CIDBIO_ERROR_NO_FINGER_DETECTED  Digital n\u00e3o foi detectada",
            "title": "C\u00f3digos de Retorno"
        },
        {
            "location": "/2_c_reference/#inicializacao-e-finalizacao",
            "text": "int32_t  CIDBIO_SetSerialCommPort  (char* comPort)  Configura em qual porta o dispositivo deve se conectar. \nDispon\u00edvel a partir da vers\u00e3o da SDK:  1.4.0  Par\u00e2metro de entrada:      comPort:  char* \n   Porta serial ao qual o dispositivo deve se conectar. Deve ser \"COMx\" em Windows e \"/dev/ttyACMx\" em Linux   int32_t  CIDBIO_Init  (void)  Checa e inicializa o dispositivo.  int32_t  CIDBIO_Terminate  (void)  Finaliza o dispositivo.",
            "title": "Inicializa\u00e7\u00e3o e Finaliza\u00e7\u00e3o"
        },
        {
            "location": "/2_c_reference/#captura-de-dedo",
            "text": "int32_t  CIDBIO_CaptureImage  (byte** imageBuf, uint32_t* width, uint32_t* height)  Captura uma imagem de um dedo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      imageBuf:  byte** \n   Buffer com o conte\u00fado bitmap da imagem. \n   Usar  CIDBIO_FreeByteArray()  para liberar mem\u00f3ria deste par\u00e2metro.  width:  uint32_t* \n   Largura da imagem  height:  uint32_t* \n   Altura da imagem   int32_t  CIDBIO_CheckFingerprint  (byte** imageBuf, uint32_t* width, uint32_t* height)  Checa se existe um dedo pressionando o leitor. Em caso positivo a imagem da digital \u00e9 retornada, em caso negativo o erro  CIDBIO_ERROR_NO_FINGER_DETECTED  \u00e9 retornado. Esta fun\u00e7\u00e3o sempre retorna imediatamente. \nDispon\u00edvel a partir da vers\u00e3o do firmware:  1.2.0  Par\u00e2metros de sa\u00edda:      imageBuf:  byte** \n   Buffer com o conte\u00fado bitmap da imagem. \n   Usar  CIDBIO_FreeByteArray()  para liberar mem\u00f3ria deste par\u00e2metro.  width:  uint32_t* \n   Largura da imagem  height:  uint32_t* \n   Altura da imagem   int32_t  CIDBIO_CaptureImageAndTemplate  (char** temp, byte** imageBuf, uint32_t* width, uint32_t* height, int32_t* quality)  Captura uma imagem de um dedo e extrai o seu template. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispostivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      temp:  char** \n   Base64 do template extra\u00eddo. \n   Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.  imageBuf:  byte** \n   Buffer com o conte\u00fado bitmap da imagem. \n   Usar  CIDBIO_FreeByteArray()  para liberar mem\u00f3ria deste par\u00e2metro.  width:  uint32_t* \n   Largura da imagem  height:  uint32_t* \n   Altura da imagem.  quality:  int32_t* \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   int32_t  CIDBIO_CaptureAndEnroll  (int64_t id)  Captura 3 imagens de um dedo e o cadastra no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado 3 vezes, ou o tempo de captura for expirado (30 segundos por itera\u00e7\u00e3o).   Par\u00e2metro de entrada:      id:  int64_t \n   N\u00famero identificador do template   int32_t  CIDBIO_CaptureAndIdentify  (int64_t* id, int32_t* score, int32_t* quality)  Captura uma imagem de um dedo e tenta encontrar uma biometria semelhante cadastrada no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      id:  int64_t* \n   N\u00famero identificador do template encontrado.  score:  int32_t* \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.  quality:  int32_t* \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   int32_t  CIDBIO_CaptureAndMatch  (int64_t id, int32_t* score, int32_t* quality)  Captura uma imagem de um dedo e verifica a semelhan\u00e7a com a biometria cadastrada com identificador  id . Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de entrada:      id:  int64_t \n   N\u00famero identificador do template a ser comparado.   Par\u00e2metros de sa\u00edda:      score:  int32_t* \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.  quality:  int32_t* \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   int32_t  CIDBIO_CancelCapture  ()  Cancela a opera\u00e7\u00e3o de captura atual. \nDispon\u00edvel a partir da vers\u00e3o do firmware:  1.2.0",
            "title": "Captura de dedo"
        },
        {
            "location": "/2_c_reference/#gerenciar-templates",
            "text": "int32_t  CIDBIO_ExtractTemplateFromImage  (uint32_t width, uint32_t height, byte* imageBuf, char** temp, int32_t* quality)  Extrai o template de uma imagem.  Par\u00e2metros de entrada:      width:  uint32_t \n   Largura da imagem  height:  uint32_t \n   Altura da imagem.  imageBuf:  byte* \n   Buffer com o conte\u00fado bitmap da imagem.     Par\u00e2metros de sa\u00edda:      temp:  char** \n   Base64 do template extra\u00eddo. \n   Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.  quality:  int32_t* \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   int32_t  CIDBIO_MergeTemplates  (char* temp1, char* temp2, char* temp3, char** tempFinal)  Mescla 3 templates em um \u00fanico template. Templates devem pertencer ao mesmo dedo. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      temp1:  char* \n   Base64 do primeiro template.   temp2:  char* \n   Base64 do segundo template.  temp3:  char* \n   Base64 do terceiro template.   Par\u00e2metros de sa\u00edda:      tempFinal:  char** \n   Base64 do template mesclado. \n   Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.   int32_t  CIDBIO_MatchTemplates  (char* temp1, char* temp2, int32_t* score)  Verifica se 2 templates s\u00e3o iguais. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      temp1:  char* \n   Base64 do primeiro template.    temp2:  char* \n   Base64 do segundo template.   Par\u00e2metros de sa\u00edda:      score:  int32_t* \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.   int32_t  CIDBIO_MatchTemplateByID  (int64_t id, char* temp, int32_t* score)  Verifica se o template  temp  \u00e9 igual ao template cadastrado com identificador  id . (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      id:  int64_t \n   identificador do template a ser verificado.  temp:  char* \n   Base64 do template.   Par\u00e2metros de sa\u00edda:      score:  int32_t* \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.   int32_t  CIDBIO_GetTemplateIDs  (int64_t** ids, uint32_t* len)  Carrega os identificadores de todos templates cadastrados.  Par\u00e2metros de sa\u00edda:      ids:  int64_t** \n   Identificadores de todos os templates cadastros no dispositivo. \n   Usar  CIDBIO_FreeIDArray()  para liberar mem\u00f3ria deste par\u00e2metro.  len:  uint32_t* \n   N\u00famero de templates cadastros no dispositivo.   int32_t  CIDBIO_GetTemplate  (int64_t id, char** temp)  Carrega o template cadastrado com identificador  id .  Par\u00e2metros de entrada:   id:  int64_t \n   Identificador do templates cadastro no dispositivo.   Par\u00e2metros de sa\u00edda:      temp:  char** \n   Base64 do template. \n   Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.   int32_t  CIDBIO_SaveTemplate  (int64_t id, char* temp)  Salva o template  temp  com o identificador  id . (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:    id:  int64_t \n   Identificador do templates cadastro no dispositivo.    temp:  char* \n   Base64 do template.    int32_t  CIDBIO_DeleteTemplate  (int64_t id)  Deleta o template cadastrado com identificador  id .  Par\u00e2metros de entrada:   id:  int64_t \n   Identificador do templates cadastro no dispositivo.   int32_t  CIDBIO_DeleteAllTemplates  (void)  Deleta todos os template cadastrados no dispositivo.",
            "title": "Gerenciar Templates"
        },
        {
            "location": "/2_c_reference/#configuracao-do-dispositivo",
            "text": "\u00c9 poss\u00edvel alterar o comportamento do dispositivo atr\u00e1ves das configura\u00e7\u00f5es abaixo:     Valor  Define  Descri\u00e7\u00e3o      1  CIDBIO_PARAM_MIN_VAR  Vari\u00e2ncia m\u00ednima para captura de um dedo. (padr\u00e3o: \"1000\")    2  CIDBIO_PARAM_SIMILIARITY_THRESHOLD  Valor de 1 a 20000 que determina o valor m\u00ednimo para 2 templates serem considerados iguais. Valor 0 para autom\u00e1tico (padr\u00e3o)    4  CIDBIO_PARAM_BUZZER_ON  \"1\" (padr\u00e3o) ou \"0\" para ligar ou desligar o buzzer    5  CIDBIO_PARAM_TEMPLATE_FORMAT  Configura o formato do template. Valores poss\u00edveis: \" ICS \": Formato propriet\u00e1rio (padr\u00e3o)  \" ANSI \": Formato ANSI (Somente para exporta\u00e7\u00e3o de templates) \" ISO \": Formato ISO  (Somente para exporta\u00e7\u00e3o de templates) \" ANSI_PLUS \": Formato ANSI com informa\u00e7\u00f5es propriet\u00e1rias  \" ISO_PLUS \": Formato ISO com informa\u00e7\u00f5es propriet\u00e1rias    6  CIDBIO_PARAM_ROTATION  Rota\u00e7\u00e3o m\u00e1xima aceita para que dois dedos sejam aceitos como iguais. Esta rota\u00e7\u00e3o \u00e9 aplicada no sentido hor\u00e1rio e anti-hor\u00e1rio. Este par\u00e2metro impacta na velocidade de identifica\u00e7\u00e3o, quanto maior este valor, mais tempo a identifica\u00e7\u00e3o demorar\u00e1. Valor de 0 a 180 (padr\u00e3o: \"30\")    7  CIDBIO_PARAM_DETECT_TIMEOUT  Tempo, em milissegundos, de espera para detec\u00e7\u00e3o de um dedo. (padr\u00e3o: \"30000\")     int32_t  CIDBIO_SetParameter  (int32_t config, char* value)  Configura o par\u00e2metro  config  com o valor  value .  Par\u00e2metros de entrada:   config:  int32_t \n   Par\u00e2metro a ser configurado  value:  char* \n   Valor a ser configurado.   int32_t  CIDBIO_GetParameter  (int32_t config, char** value)  L\u00ea o valor do par\u00e2metro  config .  Par\u00e2metros de entrada:   config:  int32_t \n   Par\u00e2metro a ser configurado   Par\u00e2metros de sa\u00edda:   value:  char** \n   Valor atual do par\u00e2metro. \n   Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.   int32_t  CIDBIO_GetDeviceInfo  (char** version, char** serialNumber, char** model)  L\u00ea as informa\u00e7\u00f5es do dispositivo.  Par\u00e2metros de sa\u00edda:   version: _char** \n   Vers\u00e3o do firmware do dispositivo. \n   Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.  serialNumber:  char** \n   N\u00famero de s\u00e9rie do dispositivo. \n   Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.  model:  char** \n   Modelo do dispositivo. \n   Usar  CIDBIO_FreeString()  para liberar mem\u00f3ria deste par\u00e2metro.   int32_t  CIDBIO_UpdateFirmware  (char* filePath)  Atualiza o firmware do dispositivo com o arquivo em  filePath . Este procedimento pode demorar alguns minutos. Por favor, n\u00e3o desconecte o dispositivo durante este per\u00edodo, pois isto pode danificar o dispositivo de forma permanente. \nA \u00faltima vers\u00e3o do fimware pode ser encontrada  aqui .  Par\u00e2metros de entrada:   filePath:  char*   \n   Caminho completo para o arquivo contendo a atualiza\u00e7\u00e3o de firmware.",
            "title": "Configura\u00e7\u00e3o do dispositivo"
        },
        {
            "location": "/2_c_reference/#desalocacao-de-memoria",
            "text": "int32_t  CIDBIO_FreeByteArray  (byte* array)  Desaloca mem\u00f3ria de um array de bytes.  Par\u00e2metros de entrada:   array:  byte*   \n   Array de bytes a ser desalocado da mem\u00f3ria.   int32_t  CIDBIO_FreeString  (char* str)  Desaloca mem\u00f3ria de uma string de c.  Par\u00e2metros de entrada:   str:  char*   \n   String a ser desalocado da mem\u00f3ria.   int32_t  CIDBIO_FreeIDArray  (int64_t* ids)  Desaloca mem\u00f3ria de um array de inteiros de 64 bits.  Par\u00e2metros de entrada:   ids:  int64_t*   \n   Array de inteiros de 64 bits a ser desalocado da mem\u00f3ria.",
            "title": "Desaloca\u00e7\u00e3o de mem\u00f3ria"
        },
        {
            "location": "/3_cpp_reference/",
            "text": "Introdu\u00e7\u00e3o\n\n\nO Wrapper C++ pode ser encontrada no \nKit de desenvolvimento do iDBIO\n. O wrapper \u00e9 composto apenas de um header que se encontra na pasta \"include\".\n\n\nTodos os m\u00e9todos apresentados abaixo pertencem \u00e0 classe \niDBio\n.\n\n\nC\u00f3digos de Retorno\n\n\nstatic int32_t \nGetErrorMessage\n (const int32_t error, std::string& msg)\n\n\nRetorna mensagem em ingl\u00eas do erro passado.\n\n\nPar\u00e2metros de entrada:\n \n\n\n\n\nerror: \nint32_t\n\n   C\u00f3digo de erro.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n \n\n\n\n\nmsg: \nstd::string&\n\n   Descri\u00e7\u00e3o em ingl\u00eas do erro.  \n\n\n\n\nTodas as fun\u00e7\u00f5es desta biblioteca retornam um n\u00famero inteiro. Este c\u00f3digo de retorno pode indicar uma das 3 situa\u00e7\u00f5es abaixo: \n\n\n\n\nSucesso (== 0) - Opera\u00e7\u00e3o foi realizada com sucesso \n\n\nAviso (> 0) - Opera\u00e7\u00e3o foi realizada mas com alguma ressalva\n\n\nErro (< 0) - Opera\u00e7\u00e3o falhou\n\n\n\n\n\n\n\n\n\n\nValor\n\n\nDefine\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\n0\n\n\nCIDBIO_SUCCESS\n\n\nOpera\u00e7\u00e3o realizada com sucesso\n\n\n\n\n\n\n1\n\n\nCIDBIO_WARNING_ALREADY_INIT\n\n\nBiblioteca j\u00e1 inicializada\n\n\n\n\n\n\n2\n\n\nCIDBIO_WARNING_NO_IDS_ON_DEVICE\n\n\nNenhum Template cadastrado\n\n\n\n\n\n\n3\n\n\nCIDBIO_WARNING_OVERWRITING_TEMPLATE\n\n\nTemplate foi sobrescrito\n\n\n\n\n\n\n-1\n\n\nCIDBIO_ERROR_UNKNOWN\n\n\nErro desconhecido\n\n\n\n\n\n\n-2\n\n\nCIDBIO_ERROR_NO_DEVICE\n\n\nDispositivo n\u00e3o encontrado\n\n\n\n\n\n\n-3\n\n\nCIDBIO_ERROR_NULL_ARGUMENT\n\n\nArgumento nulo\n\n\n\n\n\n\n-4\n\n\nCIDBIO_ERROR_INVALID_ARGUMENT\n\n\nArgumento inv\u00e1lido\n\n\n\n\n\n\n-5\n\n\nCIDBIO_ERROR_CAPTURE\n\n\nErro durante a captura\n\n\n\n\n\n\n-6\n\n\nCIDBIO_ERROR_CAPTURE_TIMEOUT\n\n\nTempo de captura expirado\n\n\n\n\n\n\n-7\n\n\nCIDBIO_ERROR_COMM_USB\n\n\nErro de comunica\u00e7\u00e3o USB\n\n\n\n\n\n\n-8\n\n\nCIDBIO_ERROR_IO_ON_HOST\n\n\nErro de comunica\u00e7\u00e3o do Host\n\n\n\n\n\n\n-9\n\n\nCIDBIO_ERROR_TEMPLATE_ALREADY_ENROLLED\n\n\nTemplate j\u00e1 cadastrado\n\n\n\n\n\n\n-10\n\n\nCIDBIO_ERROR_MERGING\n\n\nFalha no Merge\n\n\n\n\n\n\n-11\n\n\nCIDBIO_ERROR_MATCHING\n\n\nFalha no Match\n\n\n\n\n\n\n-12\n\n\nCIDBIO_ERROR_INVALID_FW_FILE\n\n\nArquivo de Firmware inv\u00e1lido\n\n\n\n\n\n\n-13\n\n\nCIDBIO_ERROR_NO_SPACE_LEFT_ON_DEVICE\n\n\nEspa\u00e7o no dispositivo esgotado\n\n\n\n\n\n\n-14\n\n\nCIDBIO_ERROR_NO_TEMPLATE_WITH_ID\n\n\nTemplate n\u00e3o cadastrado\n\n\n\n\n\n\n-15\n\n\nCIDBIO_ERROR_INVALID_ERRNO\n\n\nC\u00f3digo de erro inv\u00e1lido\n\n\n\n\n\n\n-16\n\n\nCIDBIO_ERROR_UNAVAILABLE_FEATURE\n\n\nFuncionalidade n\u00e3o dispon\u00edvel\n\n\n\n\n\n\n-17\n\n\nCIDBIO_ERROR_PREVIOUS_FW_VERSION\n\n\nVers\u00e3o do firmware \u00e9 anterior \u00e0 atual\n\n\n\n\n\n\n-18\n\n\nCIDBIO_ERROR_NOT_IDENTIFIED\n\n\nTemplate n\u00e3o identificado\n\n\n\n\n\n\n-19\n\n\nCIDBIO_ERROR_BUSY\n\n\nDispositivo esta ocupado\n\n\n\n\n\n\n-20\n\n\nCIDBIO_ERROR_CAPTURE_CANCELED\n\n\nCaptura foi cancelada\n\n\n\n\n\n\n-21\n\n\nCIDBIO_ERROR_NO_FINGER_DETECTED\n\n\nDigital n\u00e3o foi detectada\n\n\n\n\n\n\n\n\nInicializa\u00e7\u00e3o e Finaliza\u00e7\u00e3o\n\n\nstatic int32_t \nSetSerialCommPort\n (const std::string& comPort)\n\n\nConfigura em qual porta o dispositivo deve se conectar.\n\nDispon\u00edvel a partir da vers\u00e3o da SDK: \n1.4.0\n\n\nPar\u00e2metro de entrada:\n  \n\n\n\n\ncomPort: \nconst std::string&\n\n   Porta serial ao qual o dispositivo deve se conectar. Deve ser \"COMx\" em Windows e \"/dev/ttyACMx\" em Linux\n\n\n\n\nstatic int32_t \nInit\n (void)\n\n\nCheca e inicializa o dispositivo.\n\n\nstatic int32_t \nTerminate\n (void)\n\n\nFinaliza o dispositivo.\n\n\nCaptura de dedo\n\n\nint32_t \nCaptureImage\n (std::vector<byte>& imageBuf, uint32_t& width, uint32_t& height)\n\n\nCaptura uma imagem de um dedo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nimageBuf: \nstd::vector<byte>&\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\nwidth: \nuint32_t&\n\n   Largura da imagem\n\n\nheight: \nuint32_t&\n\n   Altura da imagem\n\n\n\n\nint32_t \nCheckFingerprint\n (std::vector<byte>& imageBuf, uint32_t& width, uint32_t& height)\n\n\nCheca se existe um dedo pressionando o leitor. Em caso positivo a imagem da digital \u00e9 retornada, em caso negativo o erro \nCIDBIO_ERROR_NO_FINGER_DETECTED\n \u00e9 retornado. Esta fun\u00e7\u00e3o sempre retorna imediatamente.\n\nDispon\u00edvel a partir da vers\u00e3o do firmware: \n1.2.0\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nimageBuf: \nstd::vector<byte>&\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\nwidth: \nuint32_t&\n\n   Largura da imagem\n\n\nheight: \nuint32_t&\n\n   Altura da imagem\n\n\n\n\nint32_t \nCaptureImageAndTemplate\n (std::string& temp, std::vector<byte>& imageBuf, uint32_t& width, uint32_t& height, int32_t& quality)\n\n\nCaptura uma imagem de um dedo e extrai o seu template. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nstd::string&\n\n   Base64 do template extra\u00eddo.  \n\n\nimageBuf: \nstd::vector<byte>&\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\nwidth: \nuint32_t&\n\n   Largura da imagem\n\n\nheight: \nuint32_t&\n\n   Altura da imagem.\n\n\nquality: \nint32_t&\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\nint32_t \nCaptureAndEnroll\n (int64_t id)\n\n\nCaptura 3 imagens de um dedo e o cadastra no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado 3 vezes, ou o tempo de captura for expirado (30 segundos por itera\u00e7\u00e3o). \n\n\nPar\u00e2metro de entrada:\n  \n\n\n\n\nid: \nint64_t\n\n   N\u00famero identificador do template\n\n\n\n\nint32_t \nCaptureAndIdentify\n (int64_t& id, int32_t& score, int32_t& quality)\n\n\nCaptura uma imagem de um dedo e tenta encontrar uma biometria semelhante cadastrada no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nid: \nint64_t&\n\n   N\u00famero identificador do template encontrado.\n\n\nscore: \nint32_t&\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.\n\n\nquality: \nint32_t&\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\nint32_t \nCaptureAndMatch\n (int64_t id, int32_t& score, int32_t& quality)\n\n\nCaptura uma imagem de um dedo e verifica a semelhan\u00e7a com a biometria cadastrada com identificador \nid\n. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nid: \nint64_t\n\n   N\u00famero identificador do template a ser comparado.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint32_t&\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.\n\n\nquality: \nint32_t&\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\nint32_t \nCancelCapture\n ()\n\n\nCancela a opera\u00e7\u00e3o de captura atual.\n\nDispon\u00edvel a partir da vers\u00e3o do firmware: \n1.2.0\n\n\nGerenciar Templates\n\n\nint32_t \nExtractTemplateFromImage\n (uint32_t width, uint32_t height, const std::vector<byte>& imageBuf, std::string& temp, int32_t& quality)\n\n\nExtrai o template de uma imagem.\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nwidth: \nuint32_t\n\n   Largura da imagem\n\n\nheight: uint32_t\n\n   Altura da imagem.\n\n\nimageBuf: \nconst std::vector<byte>&\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nstd::string&\n\n   Base64 do template extra\u00eddo.  \n\n\nquality: \nint32_t&\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\nint32_t \nMergeTemplates\n (const std::string& temp1, const std::string& temp2, const std::string& temp3, std::string& tempFinal)\n\n\nMescla 3 templates em um \u00fanico template. Templates devem pertencer ao mesmo dedo. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\ntemp1: \nconst std::string&\n\n   Base64 do primeiro template.  \n\n\ntemp2: \nconst std::string&\n\n   Base64 do segundo template.\n\n\ntemp3: \nconst std::string&\n\n   Base64 do terceiro template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntempFinal: \nstd::string&\n\n   Base64 do template mesclado.  \n\n\n\n\nint32_t \nMatchTemplates\n (const std::string& temp1, const std::string& temp2, int32_t& score)\n\n\nVerifica se 2 templates s\u00e3o iguais. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\ntemp1: \nconst std::string&\n\n   Base64 do primeiro template.  \n\n\ntemp2: \nconst std::string&\n\n   Base64 do segundo template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint32_t&\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.\n\n\n\n\nint32_t \nMatchTemplateByID\n (int64_t id, const std::string& temp, int32_t& score)\n\n\nVerifica se o template \ntemp\n \u00e9 igual ao template cadastrado com identificador \nid\n. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nid: \nint64_t\n\n   identificador do template a ser verificado.\n\n\ntemp: \nconst std::string&\n\n   Base64 do template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint32_t&\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.\n\n\n\n\nint32_t \nGetTemplateIDs\n (std::vector<int64_t>& ids)\n\n\nCarrega os identificadores de todos templates cadastrados.\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nids: \nstd::vector<int64_t>&\n\n   Identificadores de todos os templates cadastros no dispositivo.\n\n\n\n\nint32_t \nGetTemplate\n (int64_t id, std::string& temp)\n\n\nCarrega o template cadastrado com identificador \nid\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nid: \nint64_t\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nstd::string&\n\n   Base64 do template.  \n\n\n\n\nint32_t \nSaveTemplate\n (int64_t id, const std::string& temp)\n\n\nSalva o template \ntemp\n com o identificador \nid\n. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n\n\n\n\n\n\nid: \nint64_t\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\n\n\ntemp: \nconst std::string&\n\n   Base64 do template.\n\n\n\n\n\n\nint32_t \nDeleteTemplate\n (int64_t id)\n\n\nDeleta o template cadastrado com identificador \nid\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nid: \nint64_t\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\nint32_t \nDeleteAllTemplates\n (void)\n\n\nDeleta todos os template cadastrados no dispositivo.\n\n\nConfigura\u00e7\u00e3o do dispositivo\n\n\n\u00c9 poss\u00edvel alterar o comportamento do dispositivo atr\u00e1ves das configura\u00e7\u00f5es abaixo:\n\n\n\n\n\n\n\n\nValor\n\n\nDefine\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\n1\n\n\nCIDBIO_PARAM_MIN_VAR\n\n\nVari\u00e2ncia m\u00ednima para captura de um dedo. (padr\u00e3o: \"1000\")\n\n\n\n\n\n\n2\n\n\nCIDBIO_PARAM_SIMILIARITY_THRESHOLD\n\n\nValor de 1 a 20000 que determina o valor m\u00ednimo para 2 templates serem considerados iguais. Valor 0 para autom\u00e1tico (padr\u00e3o)\n\n\n\n\n\n\n4\n\n\nCIDBIO_PARAM_BUZZER_ON\n\n\n\"1\" (padr\u00e3o) ou \"0\" para ligar ou desligar o buzzer\n\n\n\n\n\n\n5\n\n\nCIDBIO_PARAM_TEMPLATE_FORMAT\n\n\nConfigura o formato do template. Valores poss\u00edveis:\n\"\nICS\n\": Formato propriet\u00e1rio (padr\u00e3o) \n\"\nANSI\n\": Formato ANSI  (Somente para exporta\u00e7\u00e3o de templates)\n\"\nISO\n\": Formato ISO  (Somente para exporta\u00e7\u00e3o de templates)\n\"\nANSI_PLUS\n\": Formato ANSI com informa\u00e7\u00f5es propriet\u00e1rias \n\"\nISO_PLUS\n\": Formato ISO com informa\u00e7\u00f5es propriet\u00e1rias\n\n\n\n\n\n\n6\n\n\nCIDBIO_PARAM_ROTATION\n\n\nRota\u00e7\u00e3o m\u00e1xima aceita para que dois dedos sejam aceitos como iguais. Esta rota\u00e7\u00e3o \u00e9 aplicada no sentido hor\u00e1rio e anti-hor\u00e1rio. Este par\u00e2metro impacta na velocidade de identifica\u00e7\u00e3o, quanto maior este valor, mais tempo a identifica\u00e7\u00e3o demorar\u00e1. Valor de 0 a 180 (padr\u00e3o: \"30\")\n\n\n\n\n\n\n7\n\n\nCIDBIO_PARAM_DETECT_TIMEOUT\n\n\nTempo, em milissegundos, de espera para detec\u00e7\u00e3o de um dedo. (padr\u00e3o: \"30000\")\n\n\n\n\n\n\n\n\nint32_t \nSetParameter\n (int32_t config, const std::string& value)\n\n\nConfigura o par\u00e2metro \nconfig\n com o valor \nvalue\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nconfig: \nint32_t\n\n   Par\u00e2metro a ser configurado\n\n\nvalue: \nconst std::string&\n\n   Valor a ser configurado.\n\n\n\n\nint32_t \nGetParameter\n (int32_t config, std::string& value)\n\n\nL\u00ea o valor do par\u00e2metro \nconfig\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nconfig: \nint32_t\n\n   Par\u00e2metro a ser configurado\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n\n\n\n\nvalue: \nstd::string&\n \n\n   Valor atual do par\u00e2metro.  \n\n\n\n\nint32_t \nGetDeviceInfo\n (std::string& version, std::string& serialNumber, std::string& model)\n\n\nL\u00ea as informa\u00e7\u00f5es do dispositivo.\n\n\nPar\u00e2metros de sa\u00edda:\n\n\n\n\nversion: \nstd::string&\n\n   Vers\u00e3o do firmware do dispositivo.  \n\n\nserialNumber: \nstd::string&\n\n   N\u00famero de s\u00e9rie do dispositivo.  \n\n\nmodel: \nstd::string&\n\n   Modelo do dispositivo.  \n\n\n\n\nint32_t \nUpdateFirmware\n (const std::string& filePath)\n\n\nAtualiza o firmware do dispositivo com o arquivo em \nfilePath\n. Este procedimento pode demorar alguns minutos. Por favor, n\u00e3o desconecte o dispositivo durante este per\u00edodo, pois isto pode danificar o dispositivo de forma permanente.\n\nA \u00faltima vers\u00e3o do fimware pode ser encontrada \naqui\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nfilePath: \nconst std::string&\n \n\n   Caminho completo para o arquivo contendo a atualiza\u00e7\u00e3o de firmware.\n\n\n\n\nDesaloca\u00e7\u00e3o de mem\u00f3ria\n\n\nstatic int32_t \nFreeByteArray\n (byte* array)\n\n\nDesaloca mem\u00f3ria de um array de bytes.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\narray: \nbyte*\n \n\n   Array de bytes a ser desalocado da mem\u00f3ria.\n\n\n\n\nstatic int32_t \nFreeString\n (char* str)\n\n\nDesaloca mem\u00f3ria de uma string de c.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nstr: \nchar*\n \n\n   String a ser desalocado da mem\u00f3ria.\n\n\n\n\nstatic int32_t \nFreeIDArray\n (int64_t* ids)\n\n\nDesaloca mem\u00f3ria de um array de inteiros de 64 bits.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nids: \nint64_t*\n \n\n   Array de inteiros de 64 bits a ser desalocado da mem\u00f3ria.",
            "title": "Refer\u00eancia C++"
        },
        {
            "location": "/3_cpp_reference/#introducao",
            "text": "O Wrapper C++ pode ser encontrada no  Kit de desenvolvimento do iDBIO . O wrapper \u00e9 composto apenas de um header que se encontra na pasta \"include\".  Todos os m\u00e9todos apresentados abaixo pertencem \u00e0 classe  iDBio .",
            "title": "Introdu\u00e7\u00e3o"
        },
        {
            "location": "/3_cpp_reference/#codigos-de-retorno",
            "text": "static int32_t  GetErrorMessage  (const int32_t error, std::string& msg)  Retorna mensagem em ingl\u00eas do erro passado.  Par\u00e2metros de entrada:     error:  int32_t \n   C\u00f3digo de erro.   Par\u00e2metros de sa\u00edda:     msg:  std::string& \n   Descri\u00e7\u00e3o em ingl\u00eas do erro.     Todas as fun\u00e7\u00f5es desta biblioteca retornam um n\u00famero inteiro. Este c\u00f3digo de retorno pode indicar uma das 3 situa\u00e7\u00f5es abaixo:    Sucesso (== 0) - Opera\u00e7\u00e3o foi realizada com sucesso   Aviso (> 0) - Opera\u00e7\u00e3o foi realizada mas com alguma ressalva  Erro (< 0) - Opera\u00e7\u00e3o falhou      Valor  Define  Descri\u00e7\u00e3o      0  CIDBIO_SUCCESS  Opera\u00e7\u00e3o realizada com sucesso    1  CIDBIO_WARNING_ALREADY_INIT  Biblioteca j\u00e1 inicializada    2  CIDBIO_WARNING_NO_IDS_ON_DEVICE  Nenhum Template cadastrado    3  CIDBIO_WARNING_OVERWRITING_TEMPLATE  Template foi sobrescrito    -1  CIDBIO_ERROR_UNKNOWN  Erro desconhecido    -2  CIDBIO_ERROR_NO_DEVICE  Dispositivo n\u00e3o encontrado    -3  CIDBIO_ERROR_NULL_ARGUMENT  Argumento nulo    -4  CIDBIO_ERROR_INVALID_ARGUMENT  Argumento inv\u00e1lido    -5  CIDBIO_ERROR_CAPTURE  Erro durante a captura    -6  CIDBIO_ERROR_CAPTURE_TIMEOUT  Tempo de captura expirado    -7  CIDBIO_ERROR_COMM_USB  Erro de comunica\u00e7\u00e3o USB    -8  CIDBIO_ERROR_IO_ON_HOST  Erro de comunica\u00e7\u00e3o do Host    -9  CIDBIO_ERROR_TEMPLATE_ALREADY_ENROLLED  Template j\u00e1 cadastrado    -10  CIDBIO_ERROR_MERGING  Falha no Merge    -11  CIDBIO_ERROR_MATCHING  Falha no Match    -12  CIDBIO_ERROR_INVALID_FW_FILE  Arquivo de Firmware inv\u00e1lido    -13  CIDBIO_ERROR_NO_SPACE_LEFT_ON_DEVICE  Espa\u00e7o no dispositivo esgotado    -14  CIDBIO_ERROR_NO_TEMPLATE_WITH_ID  Template n\u00e3o cadastrado    -15  CIDBIO_ERROR_INVALID_ERRNO  C\u00f3digo de erro inv\u00e1lido    -16  CIDBIO_ERROR_UNAVAILABLE_FEATURE  Funcionalidade n\u00e3o dispon\u00edvel    -17  CIDBIO_ERROR_PREVIOUS_FW_VERSION  Vers\u00e3o do firmware \u00e9 anterior \u00e0 atual    -18  CIDBIO_ERROR_NOT_IDENTIFIED  Template n\u00e3o identificado    -19  CIDBIO_ERROR_BUSY  Dispositivo esta ocupado    -20  CIDBIO_ERROR_CAPTURE_CANCELED  Captura foi cancelada    -21  CIDBIO_ERROR_NO_FINGER_DETECTED  Digital n\u00e3o foi detectada",
            "title": "C\u00f3digos de Retorno"
        },
        {
            "location": "/3_cpp_reference/#inicializacao-e-finalizacao",
            "text": "static int32_t  SetSerialCommPort  (const std::string& comPort)  Configura em qual porta o dispositivo deve se conectar. \nDispon\u00edvel a partir da vers\u00e3o da SDK:  1.4.0  Par\u00e2metro de entrada:      comPort:  const std::string& \n   Porta serial ao qual o dispositivo deve se conectar. Deve ser \"COMx\" em Windows e \"/dev/ttyACMx\" em Linux   static int32_t  Init  (void)  Checa e inicializa o dispositivo.  static int32_t  Terminate  (void)  Finaliza o dispositivo.",
            "title": "Inicializa\u00e7\u00e3o e Finaliza\u00e7\u00e3o"
        },
        {
            "location": "/3_cpp_reference/#captura-de-dedo",
            "text": "int32_t  CaptureImage  (std::vector<byte>& imageBuf, uint32_t& width, uint32_t& height)  Captura uma imagem de um dedo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      imageBuf:  std::vector<byte>& \n   Buffer com o conte\u00fado bitmap da imagem.    width:  uint32_t& \n   Largura da imagem  height:  uint32_t& \n   Altura da imagem   int32_t  CheckFingerprint  (std::vector<byte>& imageBuf, uint32_t& width, uint32_t& height)  Checa se existe um dedo pressionando o leitor. Em caso positivo a imagem da digital \u00e9 retornada, em caso negativo o erro  CIDBIO_ERROR_NO_FINGER_DETECTED  \u00e9 retornado. Esta fun\u00e7\u00e3o sempre retorna imediatamente. \nDispon\u00edvel a partir da vers\u00e3o do firmware:  1.2.0  Par\u00e2metros de sa\u00edda:      imageBuf:  std::vector<byte>& \n   Buffer com o conte\u00fado bitmap da imagem.    width:  uint32_t& \n   Largura da imagem  height:  uint32_t& \n   Altura da imagem   int32_t  CaptureImageAndTemplate  (std::string& temp, std::vector<byte>& imageBuf, uint32_t& width, uint32_t& height, int32_t& quality)  Captura uma imagem de um dedo e extrai o seu template. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      temp:  std::string& \n   Base64 do template extra\u00eddo.    imageBuf:  std::vector<byte>& \n   Buffer com o conte\u00fado bitmap da imagem.    width:  uint32_t& \n   Largura da imagem  height:  uint32_t& \n   Altura da imagem.  quality:  int32_t& \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   int32_t  CaptureAndEnroll  (int64_t id)  Captura 3 imagens de um dedo e o cadastra no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado 3 vezes, ou o tempo de captura for expirado (30 segundos por itera\u00e7\u00e3o).   Par\u00e2metro de entrada:      id:  int64_t \n   N\u00famero identificador do template   int32_t  CaptureAndIdentify  (int64_t& id, int32_t& score, int32_t& quality)  Captura uma imagem de um dedo e tenta encontrar uma biometria semelhante cadastrada no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      id:  int64_t& \n   N\u00famero identificador do template encontrado.  score:  int32_t& \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.  quality:  int32_t& \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   int32_t  CaptureAndMatch  (int64_t id, int32_t& score, int32_t& quality)  Captura uma imagem de um dedo e verifica a semelhan\u00e7a com a biometria cadastrada com identificador  id . Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de entrada:      id:  int64_t \n   N\u00famero identificador do template a ser comparado.   Par\u00e2metros de sa\u00edda:      score:  int32_t& \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.  quality:  int32_t& \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   int32_t  CancelCapture  ()  Cancela a opera\u00e7\u00e3o de captura atual. \nDispon\u00edvel a partir da vers\u00e3o do firmware:  1.2.0",
            "title": "Captura de dedo"
        },
        {
            "location": "/3_cpp_reference/#gerenciar-templates",
            "text": "int32_t  ExtractTemplateFromImage  (uint32_t width, uint32_t height, const std::vector<byte>& imageBuf, std::string& temp, int32_t& quality)  Extrai o template de uma imagem.  Par\u00e2metros de entrada:      width:  uint32_t \n   Largura da imagem  height: uint32_t \n   Altura da imagem.  imageBuf:  const std::vector<byte>& \n   Buffer com o conte\u00fado bitmap da imagem.     Par\u00e2metros de sa\u00edda:      temp:  std::string& \n   Base64 do template extra\u00eddo.    quality:  int32_t& \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   int32_t  MergeTemplates  (const std::string& temp1, const std::string& temp2, const std::string& temp3, std::string& tempFinal)  Mescla 3 templates em um \u00fanico template. Templates devem pertencer ao mesmo dedo. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      temp1:  const std::string& \n   Base64 do primeiro template.    temp2:  const std::string& \n   Base64 do segundo template.  temp3:  const std::string& \n   Base64 do terceiro template.   Par\u00e2metros de sa\u00edda:      tempFinal:  std::string& \n   Base64 do template mesclado.     int32_t  MatchTemplates  (const std::string& temp1, const std::string& temp2, int32_t& score)  Verifica se 2 templates s\u00e3o iguais. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      temp1:  const std::string& \n   Base64 do primeiro template.    temp2:  const std::string& \n   Base64 do segundo template.   Par\u00e2metros de sa\u00edda:      score:  int32_t& \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.   int32_t  MatchTemplateByID  (int64_t id, const std::string& temp, int32_t& score)  Verifica se o template  temp  \u00e9 igual ao template cadastrado com identificador  id . (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      id:  int64_t \n   identificador do template a ser verificado.  temp:  const std::string& \n   Base64 do template.   Par\u00e2metros de sa\u00edda:      score:  int32_t& \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.   int32_t  GetTemplateIDs  (std::vector<int64_t>& ids)  Carrega os identificadores de todos templates cadastrados.  Par\u00e2metros de sa\u00edda:      ids:  std::vector<int64_t>& \n   Identificadores de todos os templates cadastros no dispositivo.   int32_t  GetTemplate  (int64_t id, std::string& temp)  Carrega o template cadastrado com identificador  id .  Par\u00e2metros de entrada:   id:  int64_t \n   Identificador do templates cadastro no dispositivo.   Par\u00e2metros de sa\u00edda:      temp:  std::string& \n   Base64 do template.     int32_t  SaveTemplate  (int64_t id, const std::string& temp)  Salva o template  temp  com o identificador  id . (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:    id:  int64_t \n   Identificador do templates cadastro no dispositivo.    temp:  const std::string& \n   Base64 do template.    int32_t  DeleteTemplate  (int64_t id)  Deleta o template cadastrado com identificador  id .  Par\u00e2metros de entrada:   id:  int64_t \n   Identificador do templates cadastro no dispositivo.   int32_t  DeleteAllTemplates  (void)  Deleta todos os template cadastrados no dispositivo.",
            "title": "Gerenciar Templates"
        },
        {
            "location": "/3_cpp_reference/#configuracao-do-dispositivo",
            "text": "\u00c9 poss\u00edvel alterar o comportamento do dispositivo atr\u00e1ves das configura\u00e7\u00f5es abaixo:     Valor  Define  Descri\u00e7\u00e3o      1  CIDBIO_PARAM_MIN_VAR  Vari\u00e2ncia m\u00ednima para captura de um dedo. (padr\u00e3o: \"1000\")    2  CIDBIO_PARAM_SIMILIARITY_THRESHOLD  Valor de 1 a 20000 que determina o valor m\u00ednimo para 2 templates serem considerados iguais. Valor 0 para autom\u00e1tico (padr\u00e3o)    4  CIDBIO_PARAM_BUZZER_ON  \"1\" (padr\u00e3o) ou \"0\" para ligar ou desligar o buzzer    5  CIDBIO_PARAM_TEMPLATE_FORMAT  Configura o formato do template. Valores poss\u00edveis: \" ICS \": Formato propriet\u00e1rio (padr\u00e3o)  \" ANSI \": Formato ANSI  (Somente para exporta\u00e7\u00e3o de templates) \" ISO \": Formato ISO  (Somente para exporta\u00e7\u00e3o de templates) \" ANSI_PLUS \": Formato ANSI com informa\u00e7\u00f5es propriet\u00e1rias  \" ISO_PLUS \": Formato ISO com informa\u00e7\u00f5es propriet\u00e1rias    6  CIDBIO_PARAM_ROTATION  Rota\u00e7\u00e3o m\u00e1xima aceita para que dois dedos sejam aceitos como iguais. Esta rota\u00e7\u00e3o \u00e9 aplicada no sentido hor\u00e1rio e anti-hor\u00e1rio. Este par\u00e2metro impacta na velocidade de identifica\u00e7\u00e3o, quanto maior este valor, mais tempo a identifica\u00e7\u00e3o demorar\u00e1. Valor de 0 a 180 (padr\u00e3o: \"30\")    7  CIDBIO_PARAM_DETECT_TIMEOUT  Tempo, em milissegundos, de espera para detec\u00e7\u00e3o de um dedo. (padr\u00e3o: \"30000\")     int32_t  SetParameter  (int32_t config, const std::string& value)  Configura o par\u00e2metro  config  com o valor  value .  Par\u00e2metros de entrada:   config:  int32_t \n   Par\u00e2metro a ser configurado  value:  const std::string& \n   Valor a ser configurado.   int32_t  GetParameter  (int32_t config, std::string& value)  L\u00ea o valor do par\u00e2metro  config .  Par\u00e2metros de entrada:   config:  int32_t \n   Par\u00e2metro a ser configurado   Par\u00e2metros de sa\u00edda:   value:  std::string&   \n   Valor atual do par\u00e2metro.     int32_t  GetDeviceInfo  (std::string& version, std::string& serialNumber, std::string& model)  L\u00ea as informa\u00e7\u00f5es do dispositivo.  Par\u00e2metros de sa\u00edda:   version:  std::string& \n   Vers\u00e3o do firmware do dispositivo.    serialNumber:  std::string& \n   N\u00famero de s\u00e9rie do dispositivo.    model:  std::string& \n   Modelo do dispositivo.     int32_t  UpdateFirmware  (const std::string& filePath)  Atualiza o firmware do dispositivo com o arquivo em  filePath . Este procedimento pode demorar alguns minutos. Por favor, n\u00e3o desconecte o dispositivo durante este per\u00edodo, pois isto pode danificar o dispositivo de forma permanente. \nA \u00faltima vers\u00e3o do fimware pode ser encontrada  aqui .  Par\u00e2metros de entrada:   filePath:  const std::string&   \n   Caminho completo para o arquivo contendo a atualiza\u00e7\u00e3o de firmware.",
            "title": "Configura\u00e7\u00e3o do dispositivo"
        },
        {
            "location": "/3_cpp_reference/#desalocacao-de-memoria",
            "text": "static int32_t  FreeByteArray  (byte* array)  Desaloca mem\u00f3ria de um array de bytes.  Par\u00e2metros de entrada:   array:  byte*   \n   Array de bytes a ser desalocado da mem\u00f3ria.   static int32_t  FreeString  (char* str)  Desaloca mem\u00f3ria de uma string de c.  Par\u00e2metros de entrada:   str:  char*   \n   String a ser desalocado da mem\u00f3ria.   static int32_t  FreeIDArray  (int64_t* ids)  Desaloca mem\u00f3ria de um array de inteiros de 64 bits.  Par\u00e2metros de entrada:   ids:  int64_t*   \n   Array de inteiros de 64 bits a ser desalocado da mem\u00f3ria.",
            "title": "Desaloca\u00e7\u00e3o de mem\u00f3ria"
        },
        {
            "location": "/4_csharp_reference/",
            "text": "Introdu\u00e7\u00e3o\n\n\nO Wrapper C# pode ser encontrada no \nKit de desenvolvimento do iDBIO\n. O wrapper \u00e9 composto de uma DLL que pode ser encontrada na pasta \"C#\".\n\n\nEsta biblioteca \u00e9 somente um wrapper, \u00e9 necess\u00e1rio que a DLL \nlibcidbio.dll\n esteja na mesma pasta que esta DLL para que a biblioteca funcione apropradamente.\n\n\nTodos os m\u00e9todos apresentados abaixo pertencem \u00e0 classe \nCIDBio\n.\n\n\nC\u00f3digos de Retorno\n\n\npublic static string \nGetErrorMessage\n (RetCode error)\n\n\nRetorna mensagem em ingl\u00eas do erro passado.\n\n\nPar\u00e2metros de entrada:\n \n\n\n\n\nerror: \nRetCode\n\n   C\u00f3digo de erro.\n\n\n\n\nPar\u00e2metros de retorno:\n \n\n\n\n\nRetorno: \nstring\n\n   Descri\u00e7\u00e3o em ingl\u00eas do erro.  \n\n\n\n\nTodas as fun\u00e7\u00f5es desta biblioteca retornam um enum \nRetCode\n. Este c\u00f3digo de retorno pode indicar uma das 3 situa\u00e7\u00f5es abaixo: \n\n\n\n\nSucesso (== RetCode.SUCCESS) - Opera\u00e7\u00e3o foi realizada com sucesso \n\n\nAviso (> RetCode.SUCCESS) - Opera\u00e7\u00e3o foi realizada mas com alguma ressalva\n\n\nErro (< RetCode.SUCCESS) - Opera\u00e7\u00e3o falhou\n\n\n\n\nEste enum \u00e9 descrito pela tabela abaixo:\n\n\n\n\n\n\n\n\nValor\n\n\nNome\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\n0\n\n\nSUCCESS\n\n\nOpera\u00e7\u00e3o realizada com sucesso\n\n\n\n\n\n\n1\n\n\nWARNING_ALREADY_INIT\n\n\nBiblioteca j\u00e1 inicializada\n\n\n\n\n\n\n2\n\n\nWARNING_NO_IDS_ON_DEVICE\n\n\nNenhum Template cadastrado\n\n\n\n\n\n\n3\n\n\nWARNING_OVERWRITING_TEMPLATE\n\n\nTemplate foi sobrescrito\n\n\n\n\n\n\n-1\n\n\nERROR_UNKNOWN\n\n\nErro desconhecido\n\n\n\n\n\n\n-2\n\n\nERROR_NO_DEVICE\n\n\nDispositivo n\u00e3o encontrado\n\n\n\n\n\n\n-3\n\n\nERROR_NULL_ARGUMENT\n\n\nArgumento nulo\n\n\n\n\n\n\n-4\n\n\nERROR_INVALID_ARGUMENT\n\n\nArgumento inv\u00e1lido\n\n\n\n\n\n\n-5\n\n\nERROR_CAPTURE\n\n\nErro durante a captura\n\n\n\n\n\n\n-6\n\n\nERROR_CAPTURE_TIMEOUT\n\n\nTempo de captura expirado\n\n\n\n\n\n\n-7\n\n\nERROR_COMM_USB\n\n\nErro de comunica\u00e7\u00e3o USB\n\n\n\n\n\n\n-8\n\n\nERROR_IO_ON_HOST\n\n\nErro de comunica\u00e7\u00e3o do Host\n\n\n\n\n\n\n-9\n\n\nERROR_TEMPLATE_ALREADY_ENROLLED\n\n\nTemplate j\u00e1 cadastrado\n\n\n\n\n\n\n-10\n\n\nERROR_MERGING\n\n\nFalha no Merge\n\n\n\n\n\n\n-11\n\n\nERROR_MATCHING\n\n\nFalha no Match\n\n\n\n\n\n\n-12\n\n\nERROR_INVALID_FW_FILE\n\n\nArquivo de Firmware inv\u00e1lido\n\n\n\n\n\n\n-13\n\n\nERROR_NO_SPACE_LEFT_ON_DEVICE\n\n\nEspa\u00e7o no dispositivo esgotado\n\n\n\n\n\n\n-14\n\n\nERROR_NO_TEMPLATE_WITH_ID\n\n\nTemplate n\u00e3o cadastrado\n\n\n\n\n\n\n-15\n\n\nERROR_INVALID_ERRNO\n\n\nC\u00f3digo de erro inv\u00e1lido\n\n\n\n\n\n\n-16\n\n\nERROR_UNAVAILABLE_FEATURE\n\n\nFuncionalidade n\u00e3o dispon\u00edvel\n\n\n\n\n\n\n-17\n\n\nERROR_PREVIOUS_FW_VERSION\n\n\nVers\u00e3o do firmware \u00e9 anterior \u00e0 atual\n\n\n\n\n\n\n-18\n\n\nERROR_NOT_IDENTIFIED\n\n\nTemplate n\u00e3o identificado\n\n\n\n\n\n\n-19\n\n\nERROR_BUSY\n\n\nDispositivo esta ocupado\n\n\n\n\n\n\n-20\n\n\nERROR_CAPTURE_CANCELED\n\n\nCaptura foi cancelada\n\n\n\n\n\n\n-21\n\n\nERROR_NO_FINGER_DETECTED\n\n\nDigital n\u00e3o foi detectada\n\n\n\n\n\n\n\n\nInicializa\u00e7\u00e3o e Finaliza\u00e7\u00e3o\n\n\npublic static RetCode \nSetSerialCommPort\n (string comPort)\n\n\nConfigura em qual porta o dispositivo deve se conectar.\n\nDispon\u00edvel a partir da vers\u00e3o da SDK: \n1.4.0\n\n\nPar\u00e2metro de entrada:\n  \n\n\n\n\ncomPort: \nstring\n\n   Porta serial ao qual o dispositivo deve se conectar. Deve ser \"COMx\" em Windows e \"/dev/ttyACMx\" em Linux\n\n\n\n\npublic static RetCode \nInit\n ()\n\n\nCheca e inicializa o dispositivo.\n\n\npublic static RetCode \nTerminate\n ()\n\n\nFinaliza o dispositivo.\n\n\nCaptura de dedo\n\n\npublic RetCode \nCaptureImage\n (out byte[] imageBuf, out uint width, out uint height)\n\n\nCaptura uma imagem de um dedo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nimageBuf: \nbyte[]\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\nwidth: \nuint\n\n   Largura da imagem\n\n\nheight: \nuint\n\n   Altura da imagem\n\n\n\n\npublic RetCode \nCheckFingerprint\n (out byte[] imageBuf, out uint width, out uint height)\n\n\nCheca se existe um dedo pressionando o leitor. Em caso positivo a imagem da digital \u00e9 retornada, em caso negativo o erro \nERROR_NO_FINGER_DETECTED\n \u00e9 retornado. Esta fun\u00e7\u00e3o sempre retorna imediatamente.\n\nDispon\u00edvel a partir da vers\u00e3o do firmware: \n1.2.0\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nimageBuf: \nbyte[]\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\nwidth: \nuint\n\n   Largura da imagem\n\n\nheight: \nuint\n\n   Altura da imagem\n\n\n\n\npublic RetCode \nCaptureImageAndTemplate\n (out string temp, out byte[] imageBuf, out uint width, out uint height, out int quality)\n\n\nCaptura uma imagem de um dedo e extrai o seu template. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nstring\n\n   Base64 do template extra\u00eddo.  \n\n\nimageBuf: \nbyte[]\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\nwidth: \nuint\n\n   Largura da imagem\n\n\nheight: \nuint\n\n   Altura da imagem.\n\n\nquality: \nint\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\npublic RetCode \nCaptureAndEnroll\n (long id)\n\n\nCaptura 3 imagens de um dedo e o cadastra no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado 3 vezes, ou o tempo de captura for expirado (30 segundos por itera\u00e7\u00e3o). \n\n\nPar\u00e2metro de entrada:\n  \n\n\n\n\nid: \nlong\n\n   N\u00famero identificador do template\n\n\n\n\npublic RetCode \nCaptureAndIdentify\n (out long id, out int score, out int quality)\n\n\nCaptura uma imagem de um dedo e tenta encontrar uma biometria semelhante cadastrada no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nid: \nlong\n\n   N\u00famero identificador do template encontrado.\n\n\nscore: \nint\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.\n\n\nquality: \nint\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\npublic RetCode \nCaptureAndMatch\n (long id, int score, int quality)\n\n\nCaptura uma imagem de um dedo e verifica a semelhan\u00e7a com a biometria cadastrada com identificador \nid\n. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos). \n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nid: \nlong\n\n   N\u00famero identificador do template a ser comparado.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.\n\n\nquality: \nint\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\npublic RetCode \nCancelCapture\n ()\n\n\nCancela a opera\u00e7\u00e3o de captura atual.\n\nDispon\u00edvel a partir da vers\u00e3o do firmware: \n1.2.0\n\n\nGerenciar Templates\n\n\npublic RetCode \nExtractTemplateFromImage\n (uint width, uint height, byte[] image, out string temp, out int quality)\n\n\nExtrai o template de uma imagem.\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nwidth: \nuint\n\n   Largura da imagem\n\n\nheight: \nuint\n\n   Altura da imagem.\n\n\nimageBuf: \nbyte[]\n\n   Buffer com o conte\u00fado bitmap da imagem.  \n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nstring\n\n   Base64 do template extra\u00eddo.  \n\n\nquality: \nint\n\n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.\n\n\n\n\npublic RetCode \nMergeTemplates\n (string temp1, string temp2, string temp3, out string tempFinal)\n\n\nMescla 3 templates em um \u00fanico template. Templates devem pertencer ao mesmo dedo. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\ntemp1: \nstring\n\n   Base64 do primeiro template.  \n\n\ntemp2: \nstring\n\n   Base64 do segundo template.\n\n\ntemp3: \nstring\n\n   Base64 do terceiro template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntempFinal: \nstring\n\n   Base64 do template mesclado.  \n\n\n\n\npublic RetCode \nMatchTemplates\n (string temp1, string temp2, out int score)\n\n\nVerifica se 2 templates s\u00e3o iguais. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\ntemp1: \nstring\n\n   Base64 do primeiro template.  \n\n\ntemp2: \nstring\n\n   Base64 do segundo template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.\n\n\n\n\npublic RetCode \nMatchTemplateByID\n (long id, string temp, out int score)\n\n\nVerifica se o template \ntemp\n \u00e9 igual ao template cadastrado com identificador \nid\n. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n  \n\n\n\n\nid: \nlong\n\n   identificador do template a ser verificado.\n\n\ntemp: \nstring\n\n   Base64 do template.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nscore: \nint\n\n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.\n\n\n\n\npublic RetCode \nGetTemplateIDs\n (out long[] ids)\n\n\nCarrega os identificadores de todos templates cadastrados.\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\nids: \nlong[]\n\n   Identificadores de todos os templates cadastros no dispositivo.\n\n\n\n\npublic RetCode \nGetTemplate\n (long id, out string temp)\n\n\nCarrega o template cadastrado com identificador \nid\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nid: \nlong\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n  \n\n\n\n\ntemp: \nstring\n\n   Base64 do template.  \n\n\n\n\npublic RetCode \nSaveTemplate\n (long id, string temp)\n\n\nSalva o template \ntemp\n com o identificador \nid\n. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)\n\n\nPar\u00e2metros de entrada:\n\n\n\n\n\n\nid: \nlong\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\n\n\ntemp: \nstring\n\n   Base64 do template.\n\n\n\n\n\n\npublic RetCode \nDeleteTemplate\n (long id)\n\n\nDeleta o template cadastrado com identificador \nid\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nid: \nlong\n\n   Identificador do templates cadastro no dispositivo.\n\n\n\n\npublic RetCode \nDeleteAllTemplates\n ()\n\n\nDeleta todos os template cadastrados no dispositivo.\n\n\nConfigura\u00e7\u00e3o do dispositivo\n\n\n\u00c9 poss\u00edvel alterar o comportamento do dispositivo atr\u00e1ves do enum \nConfigParam\n.\n\nEste enum \u00e9 descrito pela tabela abaixo:\n\n\n\n\n\n\n\n\nValor\n\n\nDefine\n\n\nDescri\u00e7\u00e3o\n\n\n\n\n\n\n\n\n\n\n1\n\n\nMIN_VAR\n\n\nVari\u00e2ncia m\u00ednima para captura de um dedo. (padr\u00e3o: \"1000\")\n\n\n\n\n\n\n2\n\n\nSIMILIARITY_THRESHOLD\n\n\nValor de 1 a 20000 que determina o valor m\u00ednimo para 2 templates serem considerados iguais. Valor 0 para autom\u00e1tico (padr\u00e3o)\n\n\n\n\n\n\n4\n\n\nBUZZER_ON\n\n\n\"1\" (padr\u00e3o) ou \"0\" para ligar ou desligar o buzzer\n\n\n\n\n\n\n5\n\n\nTEMPLATE_FORMAT\n\n\nConfigura o formato do template. Valores poss\u00edveis:\n\"\nICS\n\": Formato propriet\u00e1rio (padr\u00e3o) \n\"\nANSI\n\": Formato ANSI  (Somente para exporta\u00e7\u00e3o de templates)\n\"\nISO\n\": Formato ISO  (Somente para exporta\u00e7\u00e3o de templates)\n\"\nANSI_PLUS\n\": Formato ANSI com informa\u00e7\u00f5es propriet\u00e1rias \n\"\nISO_PLUS\n\": Formato ISO com informa\u00e7\u00f5es propriet\u00e1rias\n\n\n\n\n\n\n6\n\n\nROTATION\n\n\nRota\u00e7\u00e3o m\u00e1xima aceita para que dois dedos sejam aceitos como iguais. Esta rota\u00e7\u00e3o \u00e9 aplicada no sentido hor\u00e1rio e anti-hor\u00e1rio. Este par\u00e2metro impacta na velocidade de identifica\u00e7\u00e3o, quanto maior este valor, mais tempo a identifica\u00e7\u00e3o demorar\u00e1. Valor de 0 a 180 (padr\u00e3o: \"30\")\n\n\n\n\n\n\n7\n\n\nDETECT_TIMEOUT\n\n\nTempo, em milissegundos, de espera para detec\u00e7\u00e3o de um dedo. (padr\u00e3o: \"30000\")\n\n\n\n\n\n\n\n\npublic RetCode \nSetParameter\n (ConfigParam config, string value)\n\n\nConfigura o par\u00e2metro \nconfig\n com o valor \nvalue\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nconfig: \nConfigParam\n\n   Par\u00e2metro a ser configurado\n\n\nvalue: \nstring\n\n   Valor a ser configurado.\n\n\n\n\npublic RetCode \nGetParameter\n (ConfigParam config, out string value)\n\n\nL\u00ea o valor do par\u00e2metro \nconfig\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nconfig: \nConfigParam\n\n   Par\u00e2metro a ser configurado\n\n\n\n\nPar\u00e2metros de sa\u00edda:\n\n\n\n\nvalue: \nstring\n \n\n   Valor atual do par\u00e2metro.  \n\n\n\n\npublic RetCode \nGetDeviceInfo\n (out string version, out string serialNumber, out string model)\n\n\nL\u00ea as informa\u00e7\u00f5es do dispositivo.\n\n\nPar\u00e2metros de sa\u00edda:\n\n\n\n\nversion: \nstring\n\n   Vers\u00e3o do firmware do dispositivo.  \n\n\nserialNumber: \nstring\n\n   N\u00famero de s\u00e9rie do dispositivo.  \n\n\nmodel: \nstring\n\n   Modelo do dispositivo.  \n\n\n\n\npublic RetCode \nUpdateFirmware\n (string filePath)\n\n\nAtualiza o firmware do dispositivo com o arquivo em \nfilePath\n. Este procedimento pode demorar alguns minutos. Por favor, n\u00e3o desconecte o dispositivo durante este per\u00edodo, pois isto pode danificar o dispositivo de forma permanente.\n\nA \u00faltima vers\u00e3o do fimware pode ser encontrada \naqui\n.\n\n\nPar\u00e2metros de entrada:\n\n\n\n\nfilePath: \nstring\n \n\n   Caminho completo para o arquivo contendo a atualiza\u00e7\u00e3o de firmware.",
            "title": "Refer\u00eancia C#"
        },
        {
            "location": "/4_csharp_reference/#introducao",
            "text": "O Wrapper C# pode ser encontrada no  Kit de desenvolvimento do iDBIO . O wrapper \u00e9 composto de uma DLL que pode ser encontrada na pasta \"C#\".  Esta biblioteca \u00e9 somente um wrapper, \u00e9 necess\u00e1rio que a DLL  libcidbio.dll  esteja na mesma pasta que esta DLL para que a biblioteca funcione apropradamente.  Todos os m\u00e9todos apresentados abaixo pertencem \u00e0 classe  CIDBio .",
            "title": "Introdu\u00e7\u00e3o"
        },
        {
            "location": "/4_csharp_reference/#codigos-de-retorno",
            "text": "public static string  GetErrorMessage  (RetCode error)  Retorna mensagem em ingl\u00eas do erro passado.  Par\u00e2metros de entrada:     error:  RetCode \n   C\u00f3digo de erro.   Par\u00e2metros de retorno:     Retorno:  string \n   Descri\u00e7\u00e3o em ingl\u00eas do erro.     Todas as fun\u00e7\u00f5es desta biblioteca retornam um enum  RetCode . Este c\u00f3digo de retorno pode indicar uma das 3 situa\u00e7\u00f5es abaixo:    Sucesso (== RetCode.SUCCESS) - Opera\u00e7\u00e3o foi realizada com sucesso   Aviso (> RetCode.SUCCESS) - Opera\u00e7\u00e3o foi realizada mas com alguma ressalva  Erro (< RetCode.SUCCESS) - Opera\u00e7\u00e3o falhou   Este enum \u00e9 descrito pela tabela abaixo:     Valor  Nome  Descri\u00e7\u00e3o      0  SUCCESS  Opera\u00e7\u00e3o realizada com sucesso    1  WARNING_ALREADY_INIT  Biblioteca j\u00e1 inicializada    2  WARNING_NO_IDS_ON_DEVICE  Nenhum Template cadastrado    3  WARNING_OVERWRITING_TEMPLATE  Template foi sobrescrito    -1  ERROR_UNKNOWN  Erro desconhecido    -2  ERROR_NO_DEVICE  Dispositivo n\u00e3o encontrado    -3  ERROR_NULL_ARGUMENT  Argumento nulo    -4  ERROR_INVALID_ARGUMENT  Argumento inv\u00e1lido    -5  ERROR_CAPTURE  Erro durante a captura    -6  ERROR_CAPTURE_TIMEOUT  Tempo de captura expirado    -7  ERROR_COMM_USB  Erro de comunica\u00e7\u00e3o USB    -8  ERROR_IO_ON_HOST  Erro de comunica\u00e7\u00e3o do Host    -9  ERROR_TEMPLATE_ALREADY_ENROLLED  Template j\u00e1 cadastrado    -10  ERROR_MERGING  Falha no Merge    -11  ERROR_MATCHING  Falha no Match    -12  ERROR_INVALID_FW_FILE  Arquivo de Firmware inv\u00e1lido    -13  ERROR_NO_SPACE_LEFT_ON_DEVICE  Espa\u00e7o no dispositivo esgotado    -14  ERROR_NO_TEMPLATE_WITH_ID  Template n\u00e3o cadastrado    -15  ERROR_INVALID_ERRNO  C\u00f3digo de erro inv\u00e1lido    -16  ERROR_UNAVAILABLE_FEATURE  Funcionalidade n\u00e3o dispon\u00edvel    -17  ERROR_PREVIOUS_FW_VERSION  Vers\u00e3o do firmware \u00e9 anterior \u00e0 atual    -18  ERROR_NOT_IDENTIFIED  Template n\u00e3o identificado    -19  ERROR_BUSY  Dispositivo esta ocupado    -20  ERROR_CAPTURE_CANCELED  Captura foi cancelada    -21  ERROR_NO_FINGER_DETECTED  Digital n\u00e3o foi detectada",
            "title": "C\u00f3digos de Retorno"
        },
        {
            "location": "/4_csharp_reference/#inicializacao-e-finalizacao",
            "text": "public static RetCode  SetSerialCommPort  (string comPort)  Configura em qual porta o dispositivo deve se conectar. \nDispon\u00edvel a partir da vers\u00e3o da SDK:  1.4.0  Par\u00e2metro de entrada:      comPort:  string \n   Porta serial ao qual o dispositivo deve se conectar. Deve ser \"COMx\" em Windows e \"/dev/ttyACMx\" em Linux   public static RetCode  Init  ()  Checa e inicializa o dispositivo.  public static RetCode  Terminate  ()  Finaliza o dispositivo.",
            "title": "Inicializa\u00e7\u00e3o e Finaliza\u00e7\u00e3o"
        },
        {
            "location": "/4_csharp_reference/#captura-de-dedo",
            "text": "public RetCode  CaptureImage  (out byte[] imageBuf, out uint width, out uint height)  Captura uma imagem de um dedo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      imageBuf:  byte[] \n   Buffer com o conte\u00fado bitmap da imagem.    width:  uint \n   Largura da imagem  height:  uint \n   Altura da imagem   public RetCode  CheckFingerprint  (out byte[] imageBuf, out uint width, out uint height)  Checa se existe um dedo pressionando o leitor. Em caso positivo a imagem da digital \u00e9 retornada, em caso negativo o erro  ERROR_NO_FINGER_DETECTED  \u00e9 retornado. Esta fun\u00e7\u00e3o sempre retorna imediatamente. \nDispon\u00edvel a partir da vers\u00e3o do firmware:  1.2.0  Par\u00e2metros de sa\u00edda:      imageBuf:  byte[] \n   Buffer com o conte\u00fado bitmap da imagem.    width:  uint \n   Largura da imagem  height:  uint \n   Altura da imagem   public RetCode  CaptureImageAndTemplate  (out string temp, out byte[] imageBuf, out uint width, out uint height, out int quality)  Captura uma imagem de um dedo e extrai o seu template. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      temp:  string \n   Base64 do template extra\u00eddo.    imageBuf:  byte[] \n   Buffer com o conte\u00fado bitmap da imagem.    width:  uint \n   Largura da imagem  height:  uint \n   Altura da imagem.  quality:  int \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   public RetCode  CaptureAndEnroll  (long id)  Captura 3 imagens de um dedo e o cadastra no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado 3 vezes, ou o tempo de captura for expirado (30 segundos por itera\u00e7\u00e3o).   Par\u00e2metro de entrada:      id:  long \n   N\u00famero identificador do template   public RetCode  CaptureAndIdentify  (out long id, out int score, out int quality)  Captura uma imagem de um dedo e tenta encontrar uma biometria semelhante cadastrada no dispositivo. Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de sa\u00edda:      id:  long \n   N\u00famero identificador do template encontrado.  score:  int \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.  quality:  int \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   public RetCode  CaptureAndMatch  (long id, int score, int quality)  Captura uma imagem de um dedo e verifica a semelhan\u00e7a com a biometria cadastrada com identificador  id . Quando esta fun\u00e7\u00e3o \u00e9 chamada o dispositivo entra no modo de captura de imagens. Esta fun\u00e7\u00e3o n\u00e3o retorna enquanto um dedo n\u00e3o for capturado, ou o tempo de captura for expirado (30 segundos).   Par\u00e2metros de entrada:      id:  long \n   N\u00famero identificador do template a ser comparado.   Par\u00e2metros de sa\u00edda:      score:  int \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre o dedo capturado e o cadastrado.  quality:  int \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   public RetCode  CancelCapture  ()  Cancela a opera\u00e7\u00e3o de captura atual. \nDispon\u00edvel a partir da vers\u00e3o do firmware:  1.2.0",
            "title": "Captura de dedo"
        },
        {
            "location": "/4_csharp_reference/#gerenciar-templates",
            "text": "public RetCode  ExtractTemplateFromImage  (uint width, uint height, byte[] image, out string temp, out int quality)  Extrai o template de uma imagem.  Par\u00e2metros de entrada:      width:  uint \n   Largura da imagem  height:  uint \n   Altura da imagem.  imageBuf:  byte[] \n   Buffer com o conte\u00fado bitmap da imagem.     Par\u00e2metros de sa\u00edda:      temp:  string \n   Base64 do template extra\u00eddo.    quality:  int \n   Valor de 0 a 100 que define a qualidade da imagem do dedo capturado.   public RetCode  MergeTemplates  (string temp1, string temp2, string temp3, out string tempFinal)  Mescla 3 templates em um \u00fanico template. Templates devem pertencer ao mesmo dedo. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      temp1:  string \n   Base64 do primeiro template.    temp2:  string \n   Base64 do segundo template.  temp3:  string \n   Base64 do terceiro template.   Par\u00e2metros de sa\u00edda:      tempFinal:  string \n   Base64 do template mesclado.     public RetCode  MatchTemplates  (string temp1, string temp2, out int score)  Verifica se 2 templates s\u00e3o iguais. (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      temp1:  string \n   Base64 do primeiro template.    temp2:  string \n   Base64 do segundo template.   Par\u00e2metros de sa\u00edda:      score:  int \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.   public RetCode  MatchTemplateByID  (long id, string temp, out int score)  Verifica se o template  temp  \u00e9 igual ao template cadastrado com identificador  id . (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:      id:  long \n   identificador do template a ser verificado.  temp:  string \n   Base64 do template.   Par\u00e2metros de sa\u00edda:      score:  int \n   Valor entre 0 e 20000 que define a semelhan\u00e7a entre os 2 templates.   public RetCode  GetTemplateIDs  (out long[] ids)  Carrega os identificadores de todos templates cadastrados.  Par\u00e2metros de sa\u00edda:      ids:  long[] \n   Identificadores de todos os templates cadastros no dispositivo.   public RetCode  GetTemplate  (long id, out string temp)  Carrega o template cadastrado com identificador  id .  Par\u00e2metros de entrada:   id:  long \n   Identificador do templates cadastro no dispositivo.   Par\u00e2metros de sa\u00edda:      temp:  string \n   Base64 do template.     public RetCode  SaveTemplate  (long id, string temp)  Salva o template  temp  com o identificador  id . (Formatos \"ISO\" e \"ANSI\" n\u00e3o s\u00e3o suportados para importa\u00e7\u00e3o de templates)  Par\u00e2metros de entrada:    id:  long \n   Identificador do templates cadastro no dispositivo.    temp:  string \n   Base64 do template.    public RetCode  DeleteTemplate  (long id)  Deleta o template cadastrado com identificador  id .  Par\u00e2metros de entrada:   id:  long \n   Identificador do templates cadastro no dispositivo.   public RetCode  DeleteAllTemplates  ()  Deleta todos os template cadastrados no dispositivo.",
            "title": "Gerenciar Templates"
        },
        {
            "location": "/4_csharp_reference/#configuracao-do-dispositivo",
            "text": "\u00c9 poss\u00edvel alterar o comportamento do dispositivo atr\u00e1ves do enum  ConfigParam . \nEste enum \u00e9 descrito pela tabela abaixo:     Valor  Define  Descri\u00e7\u00e3o      1  MIN_VAR  Vari\u00e2ncia m\u00ednima para captura de um dedo. (padr\u00e3o: \"1000\")    2  SIMILIARITY_THRESHOLD  Valor de 1 a 20000 que determina o valor m\u00ednimo para 2 templates serem considerados iguais. Valor 0 para autom\u00e1tico (padr\u00e3o)    4  BUZZER_ON  \"1\" (padr\u00e3o) ou \"0\" para ligar ou desligar o buzzer    5  TEMPLATE_FORMAT  Configura o formato do template. Valores poss\u00edveis: \" ICS \": Formato propriet\u00e1rio (padr\u00e3o)  \" ANSI \": Formato ANSI  (Somente para exporta\u00e7\u00e3o de templates) \" ISO \": Formato ISO  (Somente para exporta\u00e7\u00e3o de templates) \" ANSI_PLUS \": Formato ANSI com informa\u00e7\u00f5es propriet\u00e1rias  \" ISO_PLUS \": Formato ISO com informa\u00e7\u00f5es propriet\u00e1rias    6  ROTATION  Rota\u00e7\u00e3o m\u00e1xima aceita para que dois dedos sejam aceitos como iguais. Esta rota\u00e7\u00e3o \u00e9 aplicada no sentido hor\u00e1rio e anti-hor\u00e1rio. Este par\u00e2metro impacta na velocidade de identifica\u00e7\u00e3o, quanto maior este valor, mais tempo a identifica\u00e7\u00e3o demorar\u00e1. Valor de 0 a 180 (padr\u00e3o: \"30\")    7  DETECT_TIMEOUT  Tempo, em milissegundos, de espera para detec\u00e7\u00e3o de um dedo. (padr\u00e3o: \"30000\")     public RetCode  SetParameter  (ConfigParam config, string value)  Configura o par\u00e2metro  config  com o valor  value .  Par\u00e2metros de entrada:   config:  ConfigParam \n   Par\u00e2metro a ser configurado  value:  string \n   Valor a ser configurado.   public RetCode  GetParameter  (ConfigParam config, out string value)  L\u00ea o valor do par\u00e2metro  config .  Par\u00e2metros de entrada:   config:  ConfigParam \n   Par\u00e2metro a ser configurado   Par\u00e2metros de sa\u00edda:   value:  string   \n   Valor atual do par\u00e2metro.     public RetCode  GetDeviceInfo  (out string version, out string serialNumber, out string model)  L\u00ea as informa\u00e7\u00f5es do dispositivo.  Par\u00e2metros de sa\u00edda:   version:  string \n   Vers\u00e3o do firmware do dispositivo.    serialNumber:  string \n   N\u00famero de s\u00e9rie do dispositivo.    model:  string \n   Modelo do dispositivo.     public RetCode  UpdateFirmware  (string filePath)  Atualiza o firmware do dispositivo com o arquivo em  filePath . Este procedimento pode demorar alguns minutos. Por favor, n\u00e3o desconecte o dispositivo durante este per\u00edodo, pois isto pode danificar o dispositivo de forma permanente. \nA \u00faltima vers\u00e3o do fimware pode ser encontrada  aqui .  Par\u00e2metros de entrada:   filePath:  string   \n   Caminho completo para o arquivo contendo a atualiza\u00e7\u00e3o de firmware.",
            "title": "Configura\u00e7\u00e3o do dispositivo"
        }
    ]
}